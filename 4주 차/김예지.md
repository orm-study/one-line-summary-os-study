### 주변장치(I/O 디바이스, 저장장치)
- 그래픽 카드, 하드디스크, ssd, 키보드 마우스 등
- 내부구조: 주변장치들은 메인보드에 있는 버스로 연결.
- 하나의 버스는 address 버스(기억장치에서 읽을 data가 저장된 주소값 전달), data 버스(해당 기억장치에 저장된 data 전달), control 버스(읽기 신호 전달)로 이루어져 있음. (I/O 디바이스는 이 세 버스 중 하나를 받을 수 있음)
- 각 하드웨어에 맞게 외부 인터페이스 존재
- 장치의 상태와 데이터를 보관할 수 있는 각종 레지스터 존재(입출력 작업 시 데이터 저장) -> cpu가 사용하기 위해 값들이 메모리로 이동되기도 함
- 주변장치(데이터의 전송단위가 글자냐 블록이냐로 나눔)
  - 캐릭터 디바이스: 마우스, 키보드, 사운드카드, 직렬/병렬 포트
    - 적은 양의 데이터 전송(전송단위가 캐릭터(글자))
  - 블록 디바이스: 하드디스크, ssd, 그래픽 카드
    - 데이터 전송단위가 블록(범위)로 상대적으로 크기가 큼
  
-> 주변장치는 메인보드 내의 버스로 연결(옛날에는 하나의 버스로 연결해서 사용, but 입출력 작업 중 다른 작업하지 못해서, 입출력 제어기(I/O Controller)와 여러 버스 추가)
cpu는 i/o 명령 마주하면 입출력 제어기에게 입출력 작업 맡기고 다른 작업 실행
- 입출력 제어기: 두개의 채널, 시스템 버스와 입출력 버스로 구분
  - 시스템 버스: 고속으로 작동하는 cpu와 메모리가 사용
  - 입출력 버스: 주변장치가 사용(세부적으로 느린장치와 빠른장치 구분하기 위해 다시 두개의 채널로 나눠짐) -> 두개의 채널로 나누어 속도차이로 인한 병목현상 해결
    - 고속 입출력 버스: hdd
    - 저속 입출력 버스: 마우스, 키보드
  - 그래픽 카드: 매우 대용량 이라 고속 입출력 데이터 버스로도 감당x 시스템 버스 이용
  - 입출력 제어기가 메모리에 접근하기 위해서 DMA(Direct Memory Access) 제어기 추가 
  -> 입출력 제어기는 DMA로 데이터를 직접 메모리에 저장하거나 가져올 수 있음
  - cpu와 dma가 사용하는 메모리 영역 나누는데 이를 memory mapped i/o라고 함

### 마우스와 키보드
주변장치
옛날 볼 마우스: 회전 감지해서 마우스 움직임 확인
최근 광학마우스: 카메라가 달려있어 이 카메라로 초당 1500회가 넘는 사진을 찍어 마우스의 디바이스 컨트롤러 내 DSP로 보냄 -> DSP가 y축, x축 움직임 캐치
dsp가 마우스 움직임과 클릭같은 데이터 감지하면 디바이스 컨트롤러는 cpu에게 인터럽트 보내고 마우스 드라이버가 동작해서 데이터 읽어나감
마우스 드라이버는 운영체제에게 이벤트 신호 주고, 운영체제는 이를 애플리케이션으로 전달 -> 애플리케이션에서 이벤트 처리

이벤트
마우스 드라이버 -> 운영체제 -> 애플리케이션

키보드 버튼 누르면 키보드 디바이스 컨트롤러가 어떤 키를 입력받았는지 확인 -> 키보드 드라이버 -> 운영체제 -> 애플리케이션

### 하드디스크와 플래시 메모리
하드디스크 구조: 스핀들이라는 막대와 플래터라는 원판
- 플래터: 자기화된 원판(여러 트랙으로 구성되고 자성있음)
- 디스크 암이 읽기/쓰기 헤드로 플래터의 표면을 읽음
- 하드디스크의 플래터 수 2개 이상(헤드는 디스크암에 고정되어 모든 헤드는 같이 움직임)
- 실린더: 여러 플래터의 같은 트랙
- 섹터: 트랙은 여러 섹터로 나뉘고, 하드디스크의 가장 작은 단위

원판(플래터)은 실린더 -> 트랙 -> 섹터 순으로 나뉨

디스크 암을 특정 실린더로 이동시키는 것: Seek 라고 함
헤드를 실린더로 이동시키는 데 걸린 시간 Seek Time -> 이것 때문에 하드디스크가 느림
특정 트랙의 섹터에 닿을때까지 스핀들 회전

최근에는 플래시 메모리 더 많이 사용(SSD)
하드디스크 -> 공간 크게 차지 -> 기계적으로 읽어 속도가 느리고 소음 발생, 자석 갖다대면 데이터 손상, 충격에 약함
플래시메모리 -> 전기적으로 처리해서 빠르고 소음 x, 플래시 메모리는 자석 돼서 안전함, 충격에 약하지 않음, 특정한 지점에 데이터 쓰면 덮어쓰기 불가(기존 데이터 삭제해야 함, but 지우기 가능한 횟수 정해져있다.)

### 파일과 파일시스템
파일 -> 저장장치에 저장(직접 저장하면 중요 정보 훼손될 수 있기에 운영체제에 요청해서 저장)
사용자 : 데이터 저장해줘! -> 운영체제 -> 저장장치에 파일 저장
운영체제는 파일 관리 위해 파일관리자 두고 이를 파일 시스템이라고 한다.
파일관리자: 파일테이블을 이용해 파일 관리
파일시스템 기능
- 파일과 디렉토리 생성
- 파일과 디렉토리 수정/삭제
- 파일 권한 관리(운영체제는 다중 사용자 기능 제공하기에, 파일 보호하기 위해 필요)
- 파일 내용 손상되지 않도록 무결성 보장
- 백업과 복구
- 파일 암호화해 파일 보호

주변 장치: hdd/ssd -> 블록 디바이스(전송단위:블록)
사용자는 바이트 단위로 데이터에 접근해야하기에, 블록단위를 파일관리자가 바이트단위로 접근할 수 있도록 변환

유닉스 운영체제는 확장자x, 윈도우는 확장자o -> 확장자를 통해 파일의 성격을 알 수 있음

파일 = 헤더(파일 속성)+데이터
운영체제는 파일 관리위해 정보 보관하는 파일 제어블록 가지고 있음 (File Control Block, File Descriptor)
- 파일마다 독립적으로 관리, 저장장치에 저장되다가 파일 오픈되면 메모리로 이동, 파일시스템이 관리
- 파일: 데이터 집합(어떻게 구성하느냐에 따라 종류 나눌 수 있음)
  - 순차파일구조: 파일 내용 연속적으로 이어진 형태 ex) 카세트테이프 (읽기쓰기 처음부터 진행) -> 다른 위치로 이동 위해 lseek 함수 호출
    - 순서대로 저장돼서 공간 낭비x 구조 단순
    - 특정 위치로 바로 이동 어려워 데이터 삽입, 삭제 시 탐색 시간 오래걸림
  - 직접파일구조: 저장하려는 데이터를 해시함수를 통해 저장위치를 결정하는 파일구조
    - 자료구조에서 해시 테이블이라는 이름으로 불리는 방식(json도 이 방식)
    - 해시함수 사용해서 데이터 접근 빠르지만, 저장공간이 낭비
  - 인덱스 파일구조(순차파일구조와 직접파일구조 장점만 취함)
    - ex) 재생목록 -> 실행하면 순차적으로 실행되지만 바로 접근도 가능


### 디렉토리
파일을 하나의 공간에 보관 : 관련있는 파일 저장할 수 있도록 디렉토리 등장
- 여러층으로 구성, 최상위 디렉토리: 루트 디렉토리(운영체제 따라/나 C: 로 표기), 디렉토리와 디렉토리 구분 위해 / 사용

디렉토리도 파일
- 일반 파일은 데이터 저장, 디렉토리에는 파일 정보가 저장
- 디렉토리 헤더: 디렉토리 정보가 시작하는 위치 가리킴
- .: 현재 디렉토리, ..: 상위디렉토리
-> 루트디렉토리는 ..도 자기자신 가리킴

디렉토리 구조: 트리구조(계층형) , 순환이 생길 수 있는데 바로가기 기능이 있기 때문


### 파일과 디스크
파일시스템 - 메모리와 비슷
일정한 크기로 나누고 메모리에서는 페이지로 관리, 파일시스템은 블록으로 관리(하나의 블록 1~8KB)
파일시스템을 파일정보를 파일테이블로 관리(파일 시작하는 블록 위치정보도 담겨 있음)
블록을 어떻게 관리하느냐에 따라 연속할당과 불연속할당으로 나눌 수 있음
- 연속할당: 파일 구성하는 블록 연속적으로 저장, 시작점만 알면 모든 데이터 접근 가능하지만, 외부 단편화 발생 가능
- 불연속할당: 디스크 빈 공간에 블록 분산해서 저장, 파일시스템이 관리
  - 연결할당: 연결리스트 자료구조로 파일 관리
  - 불연속할당(인덱스할당): 데이터들의 인덱스를 가지고 있는 인덱스 테이블에 접근(파일 테이블의 블록테이블을 통해 데이터 접근)
    - 테이블 꽉차면 확장 가능
    - 유닉스와 리눅스에서 많이 사용
  - 디스크를 잘게 쪼개면 낭비되는 공간은 없지만 관리 빡세고 반면 디스크를 크게 쪼개면 낭비되는 공간 발생하지만 관리가 편리
  - 파일 크기보다 디스크 할당 크기가 크면? 내부 단편화가 발생한 것

- free block list 존재(빈 공간 관리하는 테이블), 파일 삭제하면 파일할당테이블의 포인터 없애고 free block list에 추가