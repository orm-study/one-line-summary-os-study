
# 운영체제의 역사와 구조

## 1. 운영체제의 역사

### 1.1 애니악과 초기 컴퓨터

- **애니악 사용 시기**: 입출력 속도가 느려서 효율성 문제 발생
- **1950년대 IC(집적 회로) 개발**: 모니터나 키보드 없이 펀치카드로 작업을 처리했으며, 기존 파이프 방식보다 더 빠른 처리 가능

### 1.2 싱글스트림 배치 시스템

- **1950년대 후반**:
    - 프로그래머 → 오퍼레이터 → CPU의 순서로 작업 처리
    - **싱글스트림 배치 시스템**: 한 번에 펀치카드로 입력을 받아 처리 후 결과 도출
    - 입출력 작업 시 CPU가 멈췄지만, 이후 I/O 처리가 가능하도록 개선됨
    - 하지만, 여전히 입력값을 기다려야 하는 한계 존재

### 1.3 1960년대: 시분할 시스템

- **시분할 시스템**: 프로그램이 순차적으로 진행되지 않고, 시간 단위로 나눠 돌아가며 실행
    - 사용자 입장에서 여러 프로그램이 동시에 실행되는 것처럼 보임
    - 하지만 CPU에 부담이 커짐
- 컴퓨터 가격이 비싸서 한 대의 컴퓨터를 여러 사용자가 사용 → **폴더 구조** 등장
- **UNIX의 탄생**: 멀티프로그래밍, 다중 사용자, 파일 시스템의 시작

### 1.4 메모리 침범 문제와 해결책

- 멀티태스킹으로 인해 **메모리 침범 이슈** 발생
    - 프로그램이 메모리 경계를 넘어가면 다른 프로그램이나 운영체제에 영향을 줄 수 있음
- **베이스 레지스터** 도입: 프로그램 시작 주소를 지정하여 메모리 침범 방지

### 1.5 1970년대: 개인용 컴퓨터의 시작

- **애플과 MS**: 개인용 컴퓨터의 상업화 시작

---

## 2. 운영체제의 구조

### 2.1 운영체제의 핵심: 커널

- **커널(Kernel)**: 프로세스, 메모리, 저장장치 관리
- 사용자는 직접 커널에 접근하지 못하며, **GUI**나 **CLI**를 통해 접근
    - **GUI**: 그래픽 사용자 인터페이스 (예: 윈도우, 맥)
    - **CLI**: 명령줄 인터페이스 (예: 리눅스)

### 2.2 시스템 콜과 드라이버

- **시스템 콜**: 어플리케이션이 커널에 접근할 수 있는 인터페이스
- **드라이버**: 하드웨어와 커널 간의 인터페이스
    - 제조사에서 드라이버를 제공해 하드웨어를 관리 (마우스, 프린터 등)

---

## 3. 컴퓨터 하드웨어와 구조

### 3.1 폰 노이만 구조

- **폰 노이만 구조**: 오늘날 대부분의 컴퓨터가 따르는 구조
    - CPU와 메모리를 버스(통로)로 연결해 데이터 처리

### 3.2 메인보드

- **메인보드**: CPU, 메모리, 하드디스크, 그래픽카드, 모니터, 마우스 등 여러 하드웨어를 연결하는 장치

### 3.3 CPU의 구성

- **CPU**는 세 가지 주요 장치로 나뉨:
    1. **산술논리연산 장치**: 데이터 연산 담당
    2. **제어 장치**: 시스템 전체의 동작을 지시하고 제어
    3. **레지스터**: 연산을 위한 임시 저장 공간 (변수처럼 사용)

---

## 4. 메모리의 종류

### 4.1 RAM

- **RAM**(Random Access Memory): 어떤 위치에서든 동일한 속도로 데이터를 읽을 수 있음
    - 전력이 끊기면 데이터 소실

### 4.2 ROM

- **ROM**(Read-Only Memory): 데이터를 한 번 저장하면 수정 불가, 전력 끊김에도 데이터 유지
    - 주로 컴퓨터 부팅 시 사용되는 **BIOS** 저장

---

## 5. 컴퓨터의 부팅 과정

1. **전원 버튼 누름**
2. *ROM(BIOS)**에서 CPU, RAM, 키보드, 마우스 등의 하드웨어 상태 확인
3. **하드디스크의 MBR**(마스터 부트 레코드)에 저장된 부트로더를 **RAM**으로 가져와 실행
4. **운영체제**를 메모리로 불러와 화면에 출력

---

## 6. 인터럽트

### 6.1 폴링 방식

- 입출력 작업 시 CPU가 주기적으로 입출력 상태를 확인하는 방식
    - 비효율적

### 6.2 인터럽트 방식

- **입출력 작업 완료** 시 CPU에게 신호를 보내서 작업을 마무리하는 방식
    - CPU가 다른 작업을 할 수 있어서 효율적
    - **인터럽트 서비스 루틴(ISR)**: 인터럽트 발생 시 실행되는 코드
    - **하드웨어 인터럽트**: 키보드, 마우스, 프린터 같은 I/O 장치에서 발생
    - **소프트웨어 인터럽트**: 오류나 예외 처리 시 발생

# 프로세스와 스레드

### 프로그램과 프로세스

**프로그램**: 하드디스크에 저장된 명령문 집합체, 즉 실행 파일(.exe)이나 앱과 같은 형태로 존재하며 수동적이다.

**프로세스**: 실행 중인 프로그램을 의미하며, 메모리에 적재된 프로그램이다. 프로그램이 메모리에 올라가 실행되면 비로소 프로세스가 된다. 프로세스는 능동적으로 작동한다. 예를 들어, 게임을 실행해서 마우스로 캐릭터를 조작하거나 키보드 단축키로 명령을 수행할 수 있다.

### 프로세스의 메모리 구조

1. **Code 영역**: 실행되는 코드가 위치.
2. **Data 영역**: 전역변수와 static 변수가 저장.
3. **Stack 영역**: 함수 호출 시 사용하는 지역변수와 매개변수, 함수가 끝났을 때 돌아갈 주소가 저장.
4. **Heap 영역**: 프로그래머가 동적으로 할당하는 메모리 공간.

### 컴파일 과정

1. **전처리기**: 매크로 치환 및 필요한 파일 불러오기 → 확장자 .i
2. **컴파일러**: 고수준 언어를 어셈블리어로 변환 → 확장자 .s
3. **어셈블러**: 어셈블리어를 기계어로 변환 → 확장자 .o
4. **링커**: 라이브러리 및 다른 코드와 연결 → 확장자 .exe
프로세스는 .exe 파일이 메모리에 적재되었을 때 운영체제에서 관리한다.

### 프로세스의 실행 흐름

CPU는 기계어를 사용하여 프로세스를 실행하며, C 언어 코드는 어셈블리어로 변환되어 CPU가 처리한다. 이 과정에서 `edx`, `eax` 같은 레지스터를 사용해 데이터를 임시로 저장하고 연산한 후 메모리에 저장한다.

### 멀티프로그래밍과 멀티프로세싱

- **유니프로그래밍**: 메모리에 하나의 프로세스만 적재되어 실행됨.
- **멀티프로그래밍**: 메모리에 여러 프로세스가 동시에 적재됨.
- **멀티프로세싱**: 여러 CPU가 여러 프로세스를 처리하는 것. 시분할 처리를 통해 교대로 실행된다.

### PCB(Process Control Block)

운영체제는 여러 프로세스를 관리하며, 각 프로세스의 정보를 PCB에 저장한다. PCB는 연결 리스트로 구성되며 프로세스 생성과 종료 시에 정보를 추가하거나 제거한다.

### PCB의 구성 요소

- **포인터**: 프로세스 간의 관계나 자원에 대한 포인터.
- **프로세스 상태**: 생성, 준비, 실행, 대기, 종료 상태를 저장.
- **프로세스 ID**: 프로세스를 식별하는 고유한 ID.
- **프로그램 카운터**: 실행될 다음 명령어의 주소.
- **레지스터 정보**: 프로세스 실행 중 사용된 레지스터 값.
- **메모리 정보**: 프로세스의 메모리 위치와 경계 레지스터 값.
- **CPU 스케줄링 정보**: 우선순위와 CPU 점유 시간 등을 저장.

### 프로세스 상태

- **생성**: 프로세스가 메모리에 적재되기 전 상태.
- **준비**: CPU 할당을 기다리는 상태.
- **실행**: CPU가 할당된 상태.
- **대기**: 입출력을 기다리는 상태.
- **종료**: 프로세스가 종료된 상태.

### 컨텍스트 스위칭

다른 프로세스를 실행하기 위해 현재 프로세스의 상태를 PCB에 저장하고, 새로운 프로세스의 상태로 교체하는 과정. 이때 프로그램 카운터와 레지스터 값 등이 PCB에 저장된다.

---

## 스레드

### 스레드의 필요성

프로세스는 독립적이며 각각 고유의 PCB, 코드, 데이터, 스택, 힙 영역을 가지지만, 프로세스 간 통신(IPC)은 비용이 많이 든다. 스레드는 한 프로세스 내에서 여러 작업을 동시에 처리할 수 있는 단위로, 효율적인 자원 공유를 통해 오버헤드를 줄일 수 있다.

### 스레드 구조

- 한 프로세스 내에서 스레드는 **코드, 데이터, 힙** 영역을 공유하며 **스택**은 개별적으로 가지고 있다.
- 스레드도 TCB(Thread Control Block)를 통해 관리된다.

### 장단점

- **안정성**: 프로세스는 독립적이므로 하나의 프로세스에 문제가 생겨도 다른 프로세스에 영향을 주지 않는다. 반면, 스레드는 같은 프로세스 내에서 동작하므로 하나의 스레드에 문제가 생기면 다른 스레드에도 영향을 줄 수 있다.
- **속도 및 자원 효율성**: 프로세스는 각자 고유한 자원을 사용하기 때문에 통신 시 오버헤드가 크지만, 스레드는 자원을 공유하므로 속도는 빠르나 안정성 문제가 생길 수 있다.

이와 같은 구조를 통해 운영체제는 프로세스와 스레드를 관리하며, 자원을 효율적으로 할당하고 처리한다.
