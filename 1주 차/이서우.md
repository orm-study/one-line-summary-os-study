## 운영체제 개요

### 운영체제 종류

- **Windows, MacOS**
    - 개인용 컴퓨터
- **유닉스, 리눅스**
    - 대형 컴퓨터나 서버용
- **안드로이드, iOS**
    - 스마트폰과 태블릿
- **임베디드 운영체제**
    - 내비게이션, 스마트 워치, 세탁기, 냉장고

### **컴퓨터는 운영체제가 있어야만 동작하는가?**

운영체제 없이도 동작은 하지만 **처음 설계한 그대로만 동작 가능**하며 다른 기능을 추가할 수 없다.

예를 들어, 유선 전화는 통화 기능만 가능한 반면 스마트폰은 운영체제가 있기 때문에 앱을 설치해 기능 추가가 가능하다.

### 운영체제가 하는 일(관리하는 것)

1. **프로세스 관리**
    
2. **메모리 관리**
    
3. **하드웨어 관리**
    
4. **파일 시스템 관리**
        
## 운영체제 구조

- **커널 (핵심)**
    - 프로세스와 메모리, 저장 장치 관리
    - 운영체제의 커널은 직접 접근 불가능
- **CLI / GUI**
    - 사용자는 CLI 또는 GUI를 통해 커널에 접근
- **시스템 콜**
    - 애플리케이션은 시스템 콜을 통해 커널에 접근
- **드라이버**
    - 하드웨어는 드라이버를 통해 커널에 접근

### 시스템 콜이 없을 경우 발생할 수 있는 문제

사용자나 애플리케이션이 하드디스크에 데이터를 저장한다고 가정한다. 시스템 콜 없이 앱이 **하드디스크에 직접 접근하면 중요한 데이터를 덮어쓸 수 있다.**

시스템 콜을 이용하면 커널에서 제공하는 write 함수를 사용하게 되는데 그럼 운영체제가 알아서 하드디스크의 빈 공간에 데이터를 저장해 준다.

## 컴퓨터 하드웨어와 구조

### 폰 노이만 구조

- **문제**
    - 초기에는 에니악과 같이 하드웨어로 프로그램을 만들었기 때문에 프로그램이 달라질 때마다 스위치와 배선 재조정 필요
- **해결**
    - 폰 노이만은 이를 해결하기 위해 **CPU와 메모리**를 두고 이들 사이는 버스(데이터 전달 통로)로 연결
- **작동 방식**
    - 메모리에 올라간 프로그램은 명령에 따라 처리되고 배선을 바꾸는 대신 소프트웨어만 변경
    - 프로그램은 메모리에 올려서 실행시키는데 프로그램을 메모리에 내장했다고 해서 프로그램 내장 방식이라고 불림

### 컴퓨터 하드웨어

- **메인 보드 (기본)**
    - 다른 하드웨어를 연결하는 장치
    - 장치 간 데이터 전송은 메인 보드의 버스가 담당
- **CPU**
- **메모리**
- **하드디스크**
- **그래픽카드**
- **모니터**
- **키보드**
- **마우스**
- **스피커**

### CPU(Central Processing Unit, 중앙 처리 장치) 구조

1. **산술 논리 연산 장치(Arithmetic and Logic Unit, ALU)**
    - 데이터 연산 담당
2. **제어 장치(Control Unit)**
    - 모든 장치들의 동작을 지시하고 제어
3. **레지스터**
    - CPU 내에서 계산을 위한 임시 보관 장치

### 메모리 종류

1. **RAM(Random Access Memory)**
    - 랜덤으로 데이터를 읽어도 저장된 위치와 상관 없이 읽는 속도 동일
    - 전력 차단 시 데이터 소멸
    - 메인 메모리로 사용
2. **ROM(Read Only Memory)**
    - 데이터를 한번 쓰면 수정 불가능
    - 전력 차단 시 데이터 보존
    - 컴퓨터 부팅과 관련된 바이오스 저장에 주로 사용

## 컴퓨터의 부팅 과정

1. 컴퓨터 전원을 누르면 ROM에 저장된 바이오스 실행
    1. 바이오스는 전원, CPU, 메모리, 키보드, 마우스, 하드디스크 등 주요 하드웨어 이상 유무 확인
    2. 이상 없을 시 하드디스크에 있는 마스터 부트 레코드에 저장된 부트 로더를 메모리로 가져와 실행
    3. 설치된 운영체제 중 어떤 운영체제를 실행할지 선택
2. 운영체제를 메모리에 적재
3. 모니터에 바탕화면 출력
4. 이제부터 실행되는 모든 응용 프로그램은 메모리에 적재돼 운영체제가 관리

## 인터럽트

CPU가 다른 작업을 처리하고 있을 때, 특정 작업에서 인터럽트라는 전기 신호를 보내면 해당 작업을 처리할 수 있도록 하는 것

1. **하드웨어 인터럽트**
    - 입출력과 같은 인터럽트
2. **소프트웨어 인터럽트**
    - 사용자 프로그램에서 발생한 인터럽트
        - 유효하지 않은 메모리 접근
        - 0으로 나누는 명령어

### CPU가 입출력 장치로부터 데이터를 읽거나 쓰려고 하는 상황

1. CPU는 입출력 작업이 들어오면 입출력 관리자에게 입출력 처리 명령
    - 이때, CPU는 입출력 명령이 언제 완료될지 알 수 없기 때문에 폴링 방식으로 주기적으로 확인이 필요하다. 인터럽트는 폴링 방식의 단점을 해결한다.
2. CPU는 다른 작업을 계속 진행
3. 입출력 관리자는 입출력 완료 시 CPU에게 전기 신호(인터럽트) 전달
    - 인터럽트는 비동기적으로 동작
4. CPU는 신호를 받아 인터럽트 서비스 루틴(ISR)을 실행시켜 작업 완료
    - 인터럽트 서비스 루틴은 발생한 특정 인터럽트를 처리하는 함수
  
## 프로그램과 프로세스

### 프로그램

하드디스크와 같은 저장 장치(SSD, HDD)에 저장된 명령문의 집합체이며, 애플리케이션이라고도 불린다. 윈도우즈 운영체제에서는 .exe 확장자를 갖는다.

### 프로세스

실행 중인 프로그램이다. 저장 장치에 저장된 프로그램이 메모리에 적재되면 프로세스라고 부른다.

프로세스는 메모리를 사용하고, 운영체제의 CPU 스케줄링 알고리즘에 따라서 CPU도 사용하고, 필요에 따라 입출력을 한다.

### 프로세스의 구조

- **코드(CODE)**
    - 자신을 실행하는 코드
- **데이터(DATA)**
    - 전역 변수와 Static(정적) 변수
- **힙(HEAP)**
    - 동적으로 메모리를 할당하는 데 쓰임
    - C언어에서는 malloc(), free() 함수를 호출하면 heap 영역의 자원을 할당/해제 가능
- **스택(STACK)**
    - 지역 변수, 호출한 함수 관련 정보

### 코드가 메모리에 올라가서 프로세스가 되고 실행되는 과정

1. 컴파일 과정을 거쳐 .exe 확장자를 갖는 프로그램으로 만듦
2. 실행 파일을 더블 클릭하면 하드디스크에 있던 파일이 메모리에 적재
3. 메모리에 적재된 프로세스는 운영체제가 관리, 운영체제의 전략에 따라 프로세스 실행
4. CPU 내의 제어 장치가 코드의 값을 메모리에 저장
5. 메모리에 저장된 값을 edx, eax 레지스터로 가져옴
6. 제어 장치가 코드를 보고 레지스터에 저장된 값을 가지고 더하라는 명령을 하면, 산술 논리 연산 장치가 값을 더하고 그 결과를 eax 레지스터에 저장
7. 제어 장치가 eax 레지스터에 저장된 결과를 가져와서 메모리에 저장

## 멀티 프로그래밍과 멀티 프로세싱

유니/멀티 프로그래밍은 메모리 관점으로 정의한 것이고, 멀티 프로세싱은 CPU 관점으로 정의한 것이다.

### 유니 프로그래밍

- 메모리에 오직 하나의 프로세스만 적재된 것
- 과거에는 메모리 크기가 작아서 유니 프로그래밍만 가능

### 멀티 프로그래밍

- 메모리에 여러 개의 프로세스가 적재된 것

### 멀티 프로세싱

- CPU가 여러 개의 프로세스를 처리하는 것
- 시분할 처리로 각각의 프로세스를 번갈아가며 짧은 시간 동안 처리

### 유니 프로그래밍과 멀티 프로세싱

메모리에 적재된 프로세스를 CPU가 처리하면 처리된 프로세스를 다른 저장 장치에 저장한다. 저장 장치에 있던 다른 프로그램을 메모리에 적재해 CPU가 처리하는 멀티 프로세싱 기법을 사용했다.

메모리에 있는 데이터를 다른 저장 장치로 보내고 저장 장치에서 메모리에 적재하는 것을 **스와핑**이라고 한다.

### 멀티 프로그래밍과 멀티 프로세싱

오늘날 OS는 멀티 프로그래밍과 멀티 프로세싱 두 개가 공존한다. 메모리에 여러 프로그램을 적재하는 멀티 프로그래밍이 있고, CPU가 시분할 처리를 통해 각 프로세스를 교대로 실행하는 멀티 프로세싱이 있다.

## PCB(Process Control Block)

- 프로세스가 만들어지면 운영체제는 해당 **프로세스의 정보를 가지는 PCB**를 만들고 저장
- PCB는 연결 리스트 자료구조로 저장
- 프로세스가 종료되면 운영체제는 연결 리스트에서 해당 프로세스의 PCB를 제거

### PCB의 구조

- **포인터**
    - 부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터 등 보유
    - 프로세스가 한 상태에서 다른 상태로 전환될 때 저장하는 포인터를 보유
    - 효율적 접근을 위해 사용
- **프로세스 상태**
    - 다섯 가지 상태인 생성, 준비, 실행, 대기, 완료 중 현재 프로세스 상태를 나타냄
- **프로세스 ID**
    - 프로세스 식별을 위한 숫자
- **프로그램 카운터**
    - 다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터 저장
    - 어떤 프로세스가 실행되다가 다른 프로세스에게 CPU를 빼앗기고 다시 실핼될 때, 원래 실행하던 명령어가 실행되게 하기 위해 필요
- **레지스터 정보**
    - 프로세스가 실행될 때 사용했던 레지스터 값들을 저장
    - 프로그램 카운터와 마찬가지로, CPU를 빼앗기고 다시 시작할 때 이전에 사용하던 값을 복구하기 위한 용도
- **메모리 관련 정보**
    - 프로세스가 있는 메모리 위치 정보, 메모리 침범을 방지하기 위한 경계 레지스터 값 등 저장
- **CPU 스케줄링 정보**
    - CPU 스케줄링에 필요한 우선순위, 최종 실행 시간, CPU 점유 시간 등 저장

이외에도 여러 가지 정보가 저장된다.

## 프로세스 상태

프로세스는 시분할 처리를 위한 다섯 가지 상태를 가지고 있다.

1. **생성(New)**
    - PCB 생성 및 메모리에 프로그램 적재 요청한 상태
    - 메모리에 프로그램 적재 승인 시 준비 상태로 전환
2. **준비(Ready)**
    - CPU를 사용하기 위해 기다리고 있는 상태
    - CPU 스케줄러에 의해 CPU 할당
3. **실행(Running)**
    - 준비 상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당 받아 실행되는 상태
    - 실행 상태에 있는 프로세스 수는 CPU의 개수와 동일(CPU n개, 실행 상태 프로세스 최대 n개)
    - CPU를 부여된 시간만큼 사용하면 CPU 스케줄러는 할당된 CPU를 강제로 빼앗고, 프로세스를 준비 상태로 전환
4. **대기(Waiting)**
    - 프로세스의 입출력 요청 시 입출력이 완료될 때까지 대기하는 상태
    - CPU는 굉장히 빠른데 입출력은 상당히 느리기 때문에 입출력이 완료될 때까지 CPU를 기다리게 하는 건 비효율적
        1. 입출력 요청을 한 프로세스를 대기 상태로 전환
        2. 다른 프로세스에게 CPU 할당
        3. 입출력 작업 완료 시 대기 상태에 있던 프로세스에게 CPU 할당 기회를 부여하기 위해 준비 상태로 전환
5. **완료(Terminated)**
    - 프로세스가 종료된 상태
    - 프로세스가 사용했던 데이터를 메모리에서 제거, PCB 제거

## 컨텍스트 스위칭

**실행 중인 프로세스를 변경하는 것**이다.

컨텍스트 스위칭이 발생하면 PCB의 내용이 변경된다. 실행 중인 프로세스의 작업 내용을 PCB에 저장하고, 실행될 기존 프로세스의 PCB 내용대로 CPU를 다시 세팅하는 것이다.

### 컨텍스트 스위칭 발생 시 PCB에서 변경되는 값

- **프로세스 상태**
- 다음 실행할 명령어의 주소를 담고 있는 **프로그램 카운터**
- **레지스터 정보**
- **메모리 관련 정보**

### 두 개의 프로세스가 컨텍스트 스위칭을 하는 상황

1. 프로세스 A가 실행 중인데 CPU 점유 시간을 초과했다.
2. 운영체제는 프로세스 A가 CPU를 너무 오래 사용했다고 판단하고 인터럽트를 발생시켜 CPU에게 전달한다.
3. 프로세스 A는 진행 중인 작업을 중단한다.
4. 나중에 중단된 상태부터 시작돼야 하기 때문에 현재 CPU의 레지스터 값 등을 PCB A에 저장한다.
5. PCB B를 참조해서 이전 프로세스 B의 상태로 CPU의 레지스터 값을 설정한다. (다음 실행할 명령어의 주소를 가지고 있는 프로그램 카운터(PC)가 있기 때문에 즉시 프로세스 B의 명령어 실행 가능)
6. 프로세스 B가 점유 시간 동안 CPU를 사용하다가 점유 시간이 다 되면 운영체제는 다시 인터럽트를 발생시킨다.
7. 프로세스 B의 현재 상태를 PCB B에 저장한다.
8. PCB A에서 프로세스 A의 상태를 가져오고 다시 프로세스 A를 실행시킨다.

이런 식으로 메모리에 있는 모든 프로세스는 컨텍스트 스위칭을 한다.

### 컨텍스트 스위칭 발생 이유

1. CPU 점유 시간이 다 되었을 때
2. I/O 요청이 발생했을 때
3. 다른 종류의 인터럽트가 발생했을 때

## 프로세스 생성과 종료

### 생성

1. .exe 파일을 더블 클릭해서 실행한다.
2. 운영체제는 해당 프로그램의 **코드 영역과 데이터 영역을 메모리에 로드**하고, **빈 스택과 빈 힙을 만들어 공간을 확보**한다.
3. 프로세스 관리를 위한 **PCB를 만들고 값을 초기화**한다.

이러한 프로세스 생성 과정은 운영체제가 부팅되고 0번 프로세스가 생성될 때 딱 한번 실행되며, 나머지 모든 프로세스는 새로 생성하지 않고 0번을 복사해서 사용한다. 새로 생성하는 것보다 복사가 더 빠르기 때문이다.

복사된 프로세스는 부모와 똑같기 때문에 자신이 원하는 코드를 실행시키기 위해서 exec()를 이용한다. fork()로 프로세스 복사 후 exec() 실행 시 부모를 복사한 자식 프로세스의 코드와 데이터 영역을 원하는 값으로 덮어쓸 수 있다.

### 종료

exit()를 호출해서 프로세스 종료를 알린 후, 부모 프로세스가 자식 프로세스를 완전히 종료시킨다.

### 좀비 프로세스

부모 프로세스가 자식 프로세스보다 먼저 종료되거나, 자식 프로세스가 비정상적으로 종료돼 exit() 신호를 주지 못하여 Exit Status를 읽지 못하면 프로세스가 메모리에 계속 살아있게 된다. 이를 좀비 프로세스라고 한다.

## 스레드

### 프로세스 방식

- 프로세스가 많아지면 그만큼 PCB, 코드, 데이터, 힙, 스택 영역을 만들어야 하며, 결국 많은 메모리 차지
- 프로세스끼리 통신하려면 IPC(Inter Process Communication)를 이용해야 하는데 비용이 상대적으로 많이 듦

**→ 프로세스의 메모리 점유 문제, IPC 통신 비용 문제를 해결하기 위해 스레드 방식 고안**

### 스레드 방식

- **스레드는 프로세스 내에 존재하는 실행 흐름**이며, 한 프로세스에 1개 이상 존재할 수 있음
- 한 프로세스의 스레드들은 PCB, 코드, 데이터, 힙 영역을 공유하며, 스택은 스레드마다 고유 영역을 가짐
- 스레드 구분을 위해 스레드 ID 부여, 관리를 위해 TCB(Thread Control Block)를 만듦 (운영체제 관점에서 스레드 구분 가능)
- 운영체제가 작업을 처리하는 단위는 프로세스 내의 스레드

### 웹 브라우저 실행 예시

- 웹 브라우저 실행 시 프로세스와 스레드가 각각 하나씩 생성됨
- 탭 추가 시 프로세스를 복사해서 사용하는 것이 아니라 스레드를 하나 더 만듦 (한 프로세스 내에 2개 스레드 존재)

**크롬 브라우저 예시 (프로세스 방식)**

- 탭 1개에 1개의 프로세스 생성
- 100개의 탭을 열면 100개 프로세스가 생성되고, 100개의 PCB와 코드, 데이터, 힙, 스택 영역 생성

**파이어폭스 브라우저 예시 (스레드 방식)**

- 처음 4개의 탭에서만 프로세스가 생성됨
- 추가적인 탭은 프로세스 내에 스레드를 추가하는 식으로 동작
- 100개의 탭을 열면 4개의 프로세스가 생성되고, 4개의 프로세스 내에 100개의 스레드가 존재
- 각 스레드는 고유 스택 영역을 가지며, 코드, 데이터, 힙 영역은 공유하기 때문에 메모리 절약

### 프로세스와 스레드의 장단점

- **안정성 (프로세스 > 스레드)**
    - **프로세스**는 독립적이기 때문에 특정 프로세스에 문제 발생 시 다른 프로세스에 영향 없음
    - **스레드**는 하나의 프로세스 내에 존재하기 때문에 해당 프로세스에 문제가 발생 시 내부의 모든 스레드에 영향
- **자원과 속도(스레드 > 프로세스)**
    - **프로세스**는 각각 고유한 자원 보유하며, 프로세스 간 통신 필요 시 IPC 이용이 필요해 오버헤드가 크고 속도가 느림
    - **스레드**는 한 프로세스 내에서 스택 영역 제외 모든 영역을 공유하기 때문에 오버헤드가 작고, 스레드 간 통신은 데이터를 공유하기 때문에 쉽게 가능하지만, 공유되는 공간에서 문제 발생 가능
