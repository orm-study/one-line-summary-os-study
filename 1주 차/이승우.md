[ 섹션1 ] 운영체제 들어가기
1. 운영체제 개요
	- 운영체제의 역활 : 1) 프로세스 관리, 2) 메모리 관리, 3) 하드웨어 관리, 4) 파일 시스템 관리

2. 운영체제의 역사
	1) 1943년 
		- 최조의 컴퓨터이자 미사일 탄도 계산을 위한 전자 디지털 계산기인 애니악 개발
		- 입출력 속도도 느리며, 하드웨어 비용이 굉장히 비쌈.
	2) 1950년 초 
		- 진공관과 전선으로 만들어진 논리회로르 아주 작은 크기로 만즌 직접회로가 개발됨
		- CPU와 메모리는 존재하였으나 키보드와 모니터가 없음.
	3) 1950년 중후반
		- 기존 시스템은 하나의 입력에 대한 결과 확인 후 다음 작업을 진행함.
			: 이는 오퍼레이터의 오버헤드가 굉장히 큼.
		- 싱글 스트림 배치 시스템
			: 여러 개의 프로그램을 순서대로 실행해서 결과를 한번에 확인할 수 있도록 개발한 시스템
		- 입출력 작업 중 CPU를 사용할 수 없는 문제가 있음
		- I/O Device 컨트롤러를 만들어 입출력 중에도 CPU가 계산할 수 있도록 함.
			: 입출력 작업이 끝나면 CPU에게 인터럽트 신호를 주고 인터럽트를 받은 CPU는 다시 처리하는 방식으로 발전함
		- CPU와 입출력을 분리하였지만 입력이 전부 완료되어야 입력 처리 작업을 진행하는 문제가 있음.
			: CPU 사용률 저하됨.
	4) 1960년
		- 시분할 시스템 개발
			: 여러 개의 프로그램을 메모리에 저장하여 시간을 나누어 빠르게 돌아가면서 실행하는 시스템
		- 하나의 컴퓨터를 두고 터미널이란 단말기를 통해 여러 사용자들이 여러 터미널로 사용가능하게 됨
			: 컴퓨터에 개인이 필요한 문서와 같은 개인정보를 저장하기 시작함.
		- AT&T 벨연구소에서 C155 유닉스 운영체제 개발
			: 멀티프로그래밍과 다중 사용자와 파일 시스템을 구현한 운영체제임.
		- 단 상기들로 인해 메모리 침법 이슈가 발생함.
	5) 1970년 이후
		- 개인용 컴퓨터의 시대가 시작함.
		- 애플의 메킨토시와 마이크로소프트의 MS-DOS가 많이 사용됨
		
3. 운영체제의 구조
	1) 커널 : 프로세서와 메모리, 저장장치를 관리하는 핵심적인 기능을 담당함.
	2) 커널 접근 방법
		- 사용자 : 인터페이스
		- 어플리케이션 : 시스템 콜 ( write 함수 사용 )
		- 하드웨어( 키보드, 마우스 같으 장치들 ) : 드라이버
	3) 인터페이스 종류 : GUI( Graphic User Interface ), CLI( Command-Line Interface ) 
	
4. 컴퓨터 하드웨어와 구조
	1) 오늘날 대부분의 컴퓨터는 프로그램 내장 방식의 폰 노이만 구조를 사용함.
	2) CPU와 메모리 사이에 버스를 연결함 ( 버스 : 데이터 전달 통로 )
	3) 프로그램 내장 방식 : 메모리에 올려서 프로그램을 실행시키는 방식
	4) 메인보드 : 다른 하드웨어를 연결하는 장치
	5) CPU( Central Processing Unit)는 중앙 처리 장치이며 아래와 같이 3가지로 구성됨
		- 산술 논리 장치( Arithmetic and Logic Unit, ALU ) : 데이터 연산 담당
		- 제어 장치 ( Control Unit ) : 모든 장치들의 동작 지시 및 제어
		- 레지스터 : CPU 내에서 계산을 위해 임시 보관 장치\
	6) 메모리 종류
		- RAM( Ramdom Access Memory )
			: 메인 메모리로 사용되며, 전력이 끊기면 데이터 사라짐.
			: 저장된 위치와 상관없이 읽는 속도 동일
		- ROM( Read Only Memory )
			: 컴퓨터 부팅과 관련된 바이오스 저장하며, 전력이 끊겨도 데이터 계속 보관 가능.
			: 데이터를 한번 쓰면 수정 불가능
		
5. 컴퓨터의 부팅과정
	1) 컴퓨터 전원 ON
	2) 바이오스 실행 : 주요 하드웨어 이상 여부 확인
	3) 이상 없는 경우 하드디스크의 부트로더를 메모리로 가져와 실행함.
	4) 운영 체제 선택( windows or 리눅스 )
	5) 운영체제를 메모리에 불러오고 모니터에 표시됨.
	6) 모든 어플리케이션은 메모리에 올라와 운영체제가 관리함.

6. 인터럽트
	1) 폴링 방식
		- 주기적으로 입출력에 대해 CPU가 확인하는 방식
		- CPU 성능저하가 단점.
	2) 인터럽트 방식
		- 입출력 완료 시 CPU에 신호를 주고 CPU는 그 신호를 받아 인터럽트 서비스 루틴을 실행시켜 작업을 완료하는 방식( 비동기적 동작 )
		- 인터럽트 서비스 루틴 : 인터럽트 발생 시 그 인터럽트를 처리하는 함수임.
		- 인버털브는 하드웨어 방식과 소프트웨어 방식이 존재함.
			하드웨어 방식 : 입출력
			소프트웨어 방식 : 사용자 프로그램에서 발생한 인터럽트 ( ex 유효하지 않은 메모리 접근 및 0 나누기 명령 )

[ 섹션2 ] 프로세스와 쓰레드
1. 프로그램과 프로세스
	1) 프로그램 : 저장장치에 저장된 명령문의 집합체( 어플리케이션, 앱, 윈도우 운영체제에서는 .exe 파일 )
	2) 프로세스 : 하드디스크에 저장된 프로그램이 메모리에 올라갔을 때 실행중인 프로그램
	3) 프로세스 구조 : 코드/데이터/스택/힙 영역으로 구성됨.
		- 코드 영역 : 프로그램 자신을 실애한느 코드가 저장됨.
		- 데이터 영역 : 전역 변수 및 스태틱 변수 저장됨.
		- 스택 영역 : 지역변수와 함수 호출 시 필요한 정보 저장됨.
		- 힙 영역 : 프로그래머가 동적으로 메모리 할당 시 사용됨.( C언어 - malloc, free 함수 )
	4) 컴파일 과정 
		① 전처리기가 매크로 정의 수자 치환 및 필요한 파일 불러옴.
			- 파일 확장자 .i
		② 컴파일러가 C언어를 어셈블리어로 바꿔줌.
			- 파일 확장자 .s
		③ 어셈블러가 어셈블리어를 기계어로 바꿔줌.
			- 파일 확장자 .o
		④ 링커가 여러가지 라이브러리나 다른 소스코드를 연결함 ( 링킹 )
			- 파일 확장자 .exe
		- 즉, Test.c 소스코드를 컴파일 커치면 test.exe라는 프로그램으로 만들어짐.
	
2. 멀티프로그래밍과 멀티프로세싱
	1) 유닛 프로그래밍 : 메모리에 오직 하나의 프로세스가 올라온 것
	2) 멀티 프로그래밍 : 메모리에 여러 개의 프로세스가 올라온 것 
	3) 멀티 프로세싱 : CPU가 시분할 처리로 여러 개의 프로세스를 처리하는 것
	4) 오늘날 OS : 멀티 프로그래밍 & 멀티 프로세싱
	4) 과거 OS는 메모리 용량 부족으로 유닛 프로그래밍 & 멀티 프로세싱을 이용함.
		- 멀티 프로세싱을 위해 스와핑 기법을 사용함.
		- 스와핑 : 메모리에 있는 프로세스를 CPU가 처리 후 다른 저장장치로 보내고 
		        다른 저장장치에 저장된 프로세스를 메모리에 올려서 CPU가 처리함.

3. PCB
	1) 운영 체제가 여러 개의 프로세스를 관리하기 위해 PCB를 만들고 저장함.
	2) PCB( Process Control Block )들은 연결리스트라는 자료구조로 저장됨.
	3) PCB 구조
		- 포인터
		- 프로세스 상태
		- 프로세스 ID : 프로세스 식별
		- 프로그램 카운터 : 다음에 실행될 명령어의 주소를 포함하는 프로그램 카운터값 저장.
		- 레지스터 정보 : 프로세스 실행될 때 사용했던 레지스터 값들 저장
		- 메모리 관련 정보 : 프로세스 위치, 메모리 침범을 막기 위한 경계 레지스터값 등
		- CPU 스케쥴링 정보 : CPU 스케쥴링에 필요한 우선순위, 최종 실행시간, CPU 점유시간 등 저장
		- etc.
		
4. 프로세스 상태
	0) 프로세스는 시분할 처리를 위한 5가지의 상태를 가지고 있음.
	1) 생성 상태( New )
		-  PCB를 생성하고 메모리의 프로그램 적재를 요청한 상태
	2) 준비 상태( Ready )
		-  CPU 사용을 위해 대기 상태
	3) 실행 상태( Running ) 
		- 준비상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태
		- 실행상태의 프로세스의 수는 CPU 갯수와 동일함.
		- CPU 점유시간을 초과하면 프로세스는 다시 준비상태로 돌아감.
	4) 대기 상태( Waiting )
		- 프로세스가 입출력 요청을 하면 입출력 완료 시까지 대기 상태임. 
		- 이 때 CPU 사용율을 높이기 위해 다른 프로세스를 CPU에게 할당함.
		- 추후 입출력 작업 완료 시 대기 상태에 있던 프로세스에 CPU 재할당
	5) 완료 상태( Terminated )
		- 프로세스가 사용했던 데이터를 메모리에서 제거하고 생성된 PCB도 제거함.
		
5. 컨텍스트 스위칭
	1) 컨텍스트 스위칭 
		- 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행 중인 프로세스의 상태를
		  저장하고 다른 프로세스의 상태값으로 교체하는 작업임.
	2) 컨텍스트 스위칭 발생 이유
		- CPU 점유시간이 다되거나, 입출력 요청이 있거나 다른 종류의 인터럽트가 있을 때 발생함.

6. 프로세스 생성과 종료
	1) 프로세스 생성
		- .exe 파일 실행 시 데이터 영역 확보 및 PCB 값 초기화함.
		- 이는 운영체제 부팅하고 0번 프로세스 생성 시 딱 한번만 실행 됨.
		- 나머지 프로세스는 새로 생성보다는 0번 프로세스를 복사해서 사용함.
		- 부모 프로세스 : 0번 프로세스 
		- 자식 프로세스 : 부모 프로세스에서 복사된 프로세스.
		- exec() 함수를 이용해 코드/데이터 영역에 원하는 값을 덮어씀.
	2) 좀비 프로세스
		- 프로세스가 정상적으로 종료되지 않고, 메모리에 계속 살아있는 상태의 프로세스를 의미함.
		- 이는 컴퓨터를 오래 켰을 때 느려지게 하는 원인 중 하나임.
		- 재부팅 시 메모리 초기화에 의해 좀비 프로세스가 사라져 다시 컴퓨터가 빨라지게 됨.
		
7. 쓰레드
	1) 쓰레드의 필요성.
		- 사용자가 운영체제에 작업을 요구하는 만큼의 프로세스가 증가하고, 그 수만큼 PCB, 코드, 데이터, 스택, 힙 영역 할당 필요함.
		- 웹브라우저 1개 실행 시 1개의 프로세스가 생성됨. 즉, 웹브라우자의 탭이 20개면 20개의 프로세스가 복사가 됨.
		- 웹브라우저 탭들의 통신인 IPC는 비용이 상대적으로 많이 필요하게 되며, 웹브라우저가 차지하는 메모리 양이 많아짐.
		- 이를 개선하고자 쓰레드라는 것을 개발함.
	2) 쓰레드란? 
		- 프로세스 내에 존재하는 것으로 1개 이상 존재 가능하며, 프로세스 내의 쓰레드들은 프로세스에 PCB, 코드, 데이터, 힙영역을 공유함.
		- 쓰레드 관리를 위해 ID 부여 및 TCB( Thread Control Block )이 생성됨.
		- 이제 운영체제 작업 처리 단위는 프로세스 내의 쓰레드임.
		- 쓰레드 적용시 웹브라우저 탭 20개 생성 시 1개의 프로세스와 쓰레드 20개가 생성되어 메모리 절약 효과를 가지게 됨.
	3) 프로세스와 쓰레드의 장단점
		① 안정성 
			- 프로세스 > 쓰레드
			- 프로세스 하나가 문제 생기면 하위 쓰레드들에도 전부 문제가 발생함.
		② 자원과 속도
			- 프로세스 < 쓰레드
			- 단, 쓰레드의 경우 쓰레드 간의 통신은 데이터 공유를 쉽게할 수 있지만 공유되는 공간에서 문제가 발생할 수 있음.
