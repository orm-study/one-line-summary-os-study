## 운영체제 들어가기

### 운영체제 개요

- 개인용 컴퓨터 : Windows, MacOS 가 많이쓰인다.
- 대형 컴퓨터나 서버용 : 유닉스, 리눅스 가 많이쓰인다.
- 스마트폰과 테블릿 : 안드로이드, iOS 가 많이쓰인다.
- 네비게이션, 스마트 워치, 냉장고, 세탁기에는 임베디드 운영체제가 들어간다.

- 컴퓨터는 운영체제가 있어야 동작하는가? 정답은 "없어도 동작한다"
- 운영체제가 없으면 다른 기능을 추가할 수 없고 처음 설계한 그대로만 동작한다.
  ex) 예전에 사용하던 유선 전화기 : 통화기능만 가능
  운영체제가 있는 스마트폰 : 애플리케이션을 설치해 기능을 추가할 수 있다.

### 운영체제가 하는 일

1. 프로세스 관리 : 인터넷, 노래, 게임이 전부 동시에 실행된다.

- 주로 사용하는 프로세스만 실행되고 나머진 백그라운드에서 실행된다.
- 만약 운영체제가 관리를 하지않는다면 브라우저가 인터넷이 CPU를 독차지해서 게임이 실행되지않거나, 게임이 CPU를 독차지해서 인터넷이 실행되지않는다.

2. 메모리 관리

- 여러 프로그램을 동시에 관리하기때문에 동시에 관리하기위해 메모리를 사용한다.

3. 하드웨어 관리

- 운영체제는 사용자의 하드웨어에 대한 직접적인 접근을 막는다.
- 이유는 하드디스크의 특정 영역에 중요한 데이터가 있을수도 있고 사용자가 악의적으로 공경할 수 있기 때문이다.

4. 파일 시스템 관리

- 하드디스크에 많은 파일들의 효율적인 저장과 관리를 하기 위한 방법이다.

### 운영체제의 역사

- 1940: 에니악
  - 입출력 속도가 매우 느리고 무거움
- 1950 초: 논리회로를 작은 크기로 만든 직접회로 → 현대적인 컴퓨터 형상 만들어짐
- 1950 중후반
  - 오퍼레이터를 통해 cpu에 전달하는 과정에서 생기는 오버헤드 문제 해결을 위해 오퍼레이터에 여러개의 작업을 한번에 요청하는 “싱글스트림 배치시스템” 도입
  - 당시에 입출력 시 CPU 사용할 수 없었는데 입출력 담당하는 I/O 디바이스 컨트롤러를 만들어 입출력 중에도 CPU가 계산할 수 있도록 만듦. I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 인터럽트를 보내 CPU가 작업을 처리할 수 있도록 함.
  - 입출력에도 CPU를 기다려야 하는 작업 있는데, 입력은 CPU의 연산을 기다려야하기 때문에 CPU 사용률이 떨어짐.(싱글 스트림 배치 시스템의 한계)
- 1960
  - 싱글 스트림 배치 시스템 해결: 프로그램을 하나씩 처리하는게 아니라 여러 프로그램을 번갈아가면서 실행해 사용자에게는 동시에 실행하는 것처럼 보임(시분할 시스템)
  - 당시 컴퓨터가 비싸서 여러 터미널을 통해 여러 사용자가 컴퓨터에 접근.
    - 이 때문에 개인적인 파일을 저장하기도 해서 ‘파일시스템 등장’
  - UNIX
    - 동시에 여러 개 실행시키는 ‘멀티프로그래밍’
    - 여러 사용자 지원하는 ‘다중 사용자’
    - ‘파일시스템’
  - 다른 프로그램의 메모리에 접근하거나 os의 메모리에 접근하게 되는 경우 문제가 생김
    - 여러 프로그램이 실행되니까 하드웨어 적으로 ‘베이스 레지스터’를 추가해서 시작 주소 저장하고 모든 프로그램은 0번 주소부터 시작한다고 가정
- 1970
  - 개인용 컴퓨터의 시대가 시작, 저렴해져서 개인이 소유하기 쉬워짐

### 운영체제의 구조

- 운영체제의 핵심은 ? '커널'
- 커널은 프로세스와 메모리, 저장장치를 관리하는 핵심기능을 담당
- 사용자는 인터페이스를 통해서만 운영체제의 커널에 접근가능
- 인터페이스 종류 : GUI CLI 그림이냐 텍스트냐 차이이다.
- Graphic User Interface / Command-Line Interface

- 어플리케이션은 시스템 콜을 통해서 커널에 접근할 수 있다.
- 커널은 사용자로부터 자신을 보호하기위해서 '시스템 콜' 이라는 인터페이스를 가지고 있다.
- 사용자의 어플리케이션이 하드디스크에 데이터를 저장할때 중요한데이터를 덮어 쓸수도있는데 시스템콜을 이용하면 빈공간에 저장하게 된다.

- 하드웨어와 커널의 인터페이스는 드라이버를 사용한다.
- 운영체제는 많은 종류의 하드웨어를 전부 지원해야 하기 때문에 드라이버를 사용한다.

### 컴퓨터 하드웨어와 구조

폰 노이만 구조 : CPU 와 메모리를 버스(데이터를 전달하는 통로)로 연결

- 프로그램은 메모리에 올려서 실행시키는데 이를 메모리 내장방식 이라고한다.

- 컴퓨터 하드웨어 - CPU, 메모리, 하드 디스크, 그래픽카드, 모니터, 키보드, 마우스, 스피커
- 메인보드는 다른 하드웨어를 연결하는 장치

- CPU (Central Processing Unit) : 중앙처리장치
- CPU 구조 :
  산술논리 연산장치 - 실제로 데이터 연산을 담당
  제어장치 - 모든 장치들의 동작을 지시하고 제어하는 장치
  레지스터 - 계산을 위해 임시로 보관하는 장치

- 메모리 종류
  RAM - Ramdom으로 데이터를 읽어도 저장된 위치와 상관 없이 읽는 속도가 같습니다. 전력이 끊기면 데이터 날라감
  ROM - 데이터를 한번쓰면 수정이 불가능합니다. 전력이 끊겨도 데이터 보존됨. 부팅과 관련된 바이오스에 주로쓰임.

### 컴퓨터 부팅 과정

- 컴퓨터의 전원을 누르면 ROM에 저장된 바이오스가 실행됩니다.
- 바이오스는 전원, CPU, 메모리, 키보드, 마우스, 하드디스크등 주요하드웨어에 이상이 없는지 체크합니다.
- 주요 장치에 이상이 있다면 오류음을 내면서 부팅이 이루어 지지않고, 이상이 없다면 부팅이됩니다.
- 운영체제가 여러개면 선택가능, 운영체제가 하나이면 바로 운영체제를 메모리로 불러오고 모니터에 바탕화면이 보이게 된다.

### 인터럽트

- CPU는 입출력 명령이 내려오면 입출력 관리자에게 입출력 명령을 내립니다.
- 폴링(Polling) - 주기적으로 CPU가 확인해줘야하니 성능이 좋지않다.
- CPU관점에서는 입출력 명령이 언제 완료될지 알 수 없기 때문에 주기적으로 계속 확인해줘야합니다.
- 폴링의 단점을 해결한것이 인터럽트 방식이다.
- CPU가 입출력 관리자에게 입출력 명령을 내리고 자기는 다른 작업을 계속 합니다.
- CPU에게 신호를 주고 CPU는 그 신호를 받아 인터럽트 서비스 루틴(ISR)을 실행시켜 작업을 완료합니다.
- 인터럽트는 비동기적으로 동작하기 때문에 성능에 이점이 있습니다.
- 인터럽트는 두가지 방식이 있습니다.
- 하드웨어 방식 : 하드웨어 방식은 조금 전 설명한 입출력 등과 같은 인터럽트가 있다.
- 소프트웨어 방식 : 소프트웨어 방식은 사용자 프로그램에서 발생한 인터럽트가 있다.
- ex) 0으로 나누는 명령어, 유효하지 않은 메모리 접근

### 프로그램과 프로세스

- 프로그램 : 하드디스크같은 저장장치에 저장된 명령문의 집합체를 말합니다.
- 애플리케이션이나 앱 이라고 불리고 윈도우 운영체제에서는 .exe 파일의 모습을 하고 있습니다.

- 프로세스 : 실행중인 프로그램
- 하드디스크에 저장된 프로그램이 메모리(RAM)에 올라갔을때 실행중인 프로그램, 즉 프로세스라고 불립니다.
- 프로그램은 컴퓨터 관점에서 하드 디스크, 즉 저장 장치만 사용하는 수동적인 존재입니다.
- 반면에 프로세스는 메모리도 사용하고 운영체제에 따라서 CPU도 사용하고 필요에따라 입출력을 하기때문에 능동적인 존재라고 말할 수 있다.
- 프로세스의 영역 - CODE영역, DATA영역, HEAP영역, STACK영역
- Code 영역은 자신을 실행하는 코드가 저장되어있고
- Data 영역은 전역 변수와 Static(정적) 변수가 저장되어 있습니다.
- Stack 영역은 지역변수와 함수 호출을 했을때 필요한 정보들이 저장됩니다.
- Heap 영역은 프로그래머가 동적으로 메모리를 할당하는 데에 쓰입니다. (프로그래머가 런타임시 할당할 수 있는 메모리 공간)

- 작성한 코드가 메모리에 올라가서 프로세스가 되는과정
- 컴파일 과정은 먼저 전처리기를 거쳐서 매크로로 정의한 숫자를 치환하고 필요한 파일을 불러옵니다.
- 전처리기를 거치면 파일의 확장자는 .i 가 됩니다.
- 컴파일러가 컴파일을 해줍니다.
- 컴파일을 마치면 고수준인 C언어를 저수준인 어셈블리어로 바꿔줍니다.
- 컴파일러를 거치면 파일의 확장자는 .s 가 됩니다.
- 이제 어셈블러가 어셈블리어를 기계어로 바꿔줍니다.
- 그럼 이파일은 0과 1로 이루어진 기계어로 구성되고 파일의 확장자는 .o가 됩니다.
- 기계어로 되어있기 때문에 파일을 텍스트 에디터로 열어보면 글씨가 깨져서 보입니다.
- 마지막으로 링커가 링킹을 합니다. 여러가지 라이브러리나 다른 소스코드를 연결합니다.
- 이렇게 링킹까지 거치면 파일의 확장자는 .exe 가 됩니다.
- .exe 를 더블클릭하면 파일이 메모리에 올라가게되고 비로소 프로세스라는 새로운 이름으로 불리게 됩니다.

### 유니프로그래밍, 멀티프로그래밍, 멀티프로세싱

- 유니프로그래밍 : 메모리에 프로세스 1개
- 멀티프로그래밍 : 메모리에 프로세스 여러개
- 멀티프로세싱 : CPU가 여러 개의 프로세스를 처리하는 것을 말합니다.
- 스와핑 : 메모리에 있는 데이터를 다른 저장장치로 보내고 다른 저장장치에서 메모리에 올리는 것

### PCB (Process Controll Block)

- 프로그램이 메모리에 올라가서 실행중인 상태를 프로세스 라고 말합니다
- 운영체제는 여러개의 프로세스를 전부 다 관리한다.
- 프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고있는 PCB를 만들고 저장합니다.
- PCB들은 연결리스트라는 자료구조로 저장됩니다.
- 운영체제는 프로세스가 종료되면 연결리스트에서 해당 프로세스의 PCB를 제거합니다.
- PCB의 구조
- 포인터 : 부모와 자식 프로세스에 대한 포인터와 할당된 자원에 대한 포인터등이 있고 프로세스의 한 상태에서 다른 상태로 전환될때 저장하는 포인터
- 프로세스 상태 : 현재 프로세스의 다섯가지 상태 (생성, 준비, 실행, 대기, 완료)
- 프로세스 ID : 프로세스를 식별하기 위한 숫자가 저장됩니다.
- 프로그램 카운터 : 다음에 실행될 명령어 주소를 포함하는 프로그램 카운터를 저장
- 레지스터 정보 : 프로세스가 실행될 때 사용했던 레지스터 값들이 저장됩니다.
- 메모리 관련 정보 : 프로세스가 메모리에 있는 위치 정보, 메모리 침범을 막기위한 경계 레지스터 값이 저장
- CPU 스케줄링 정보 : CPU 스케줄링에 필요한 우선순위, 최종 실행시간, CPU 점유시간 등이 저장

### 프로세스 상태

- 시분할 프로세스를 사용하는 운영체제는 여러개의 프로세스를 돌아가면서 실행합니다.
- CPU는 한순간에는 하나의 프로세스밖에 처리하지 못한다. 다만 속도가 너무빨라서 사람이 보기에는 동시에 실행되는 것처럼 보인다.
- 프로세스는 시분할 처리를 위한 다섯가지 상태를 가지고 있다.
- 생성상태는 PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태 메모리에 프로그램 적재를 승인받으면 준비상태로 넘어갑니다
- 준비상태는 CPU를 사용하기 위해 기다리고 있는 상태 준비상태에 있는 프로세스는 CPU 스케줄러에 의해 CPU가 할당됩니다. 대부분의 프로세스는 준비상태
- 실행상태는 준비상태에 있는 프로세스가 CPU스케줄러에 의해 CPU를 할당받아 실행되는 상태
- 실행상태에 있는 프로세스의 수는 CPU의 개수만큼 입니다.
- 대기상태는 프로세스가 입출력 요청을 하면 입출력이 완료될 때 까지 기다리는 상태입니다.
- 완료상태는 프로세스가 종료된 상태 프로세스가 사용했던 데이터를 메모리에서 제거하고 생성된 PCB도 제거합니다.

### 컨텍스트 스위칭

- 컨텍스트 스위칭은 프로세스를 실행하는 중에 다른 프로세스를 실행하기 위해 실행중인 프로세스의 상태를 저장하고 다른 프로세스의 상태값으로 교체하는 작업
- 컨텍스트 스위칭이 일어날때 PCB의 내용이 변경됩니다.
- 실행중인 프로세스의 작업내용을 PCB에 저장하고 실행될 기존 프로세스의 PCB의 내용대로 CPU가 다시 세팅됩니다.
- 컨텍스트 스위칭이 일어날 때 PCB에 변경하는 값들로는 프로세스상태, 프로그램 카운터, 각종 레지스터 값등이 있습니다.
- 프로세스 두 개가 컨텍스트 스위칭을 하는 상황
- 프로세스 A가 CPU 점유시간을 초과했습니다.
- 운영체제는 프로세스 A가 CPU를 너무 오래 사용했다고 판단하고 인터럽트를 발생시킵니다.
- 프로세스 A는 하던 일을 멈춥니다.
- 나중에 현재 상태에서 시작되어야 하기 때문에 현재 CPU의 레지스터 값 등을 PCB A에 저장합니다.
- PCB B를 참조해서 이전 프로세스 B의 상태로 CPU의 레지스터 값을 설정합니다.
- 프로세스 B가 점유시간동안 CPU를 사용하다가 점유시간이 다되면 운영체제는 다시 인터럽트를 발생시킵니다.
- 그리고 프로세스 B의 현재 상태를 PCB B에 저장하고
- PCB A에서 프로세스 A의 사앹를 가져오고 다시 프로세스 A를 실행시킵니다.
- 이런식으로 메모리에 있는 모든 프로세스들은 컨텍스트 스위칭을 합니다.

### 프로세스 생성과 종료

-

### 쓰레드

- 프로세스 : 운영체제가 작업을 처리하는 단위
- 프로세스가 많아지면 그 수만큼 PCB, 코드, 데이터, 스택, 힙 영역이 만들어지기때문에 너무 무거워진다.
- 그래서 나온게 쓰레드
- 쓰레드는 프로세스 내에 존재하는것으로 1개 이상 있을 수 있다.
- 쓰레드는 PCB, 코드, 데이터, 힙 영역을 공유하고 스택은 공유하지않고 쓰레드마다 하나씩 가지고 있습니다.
- 이제 운영체제가 작업을 처리하는 단위는 프로세스 내의 쓰레드 이다.

- 프로세스와 쓰레드의 장단점
- 프로세스는 서로 독립적이기때문에 안정성이 우수하다.
- 스레드는 하나의 프로세스내에 존재하기땜누에 안정성이 안좋다.
- IPC : 프로세스 간의 통신
- 속도와 자원 면에서는 스레드가 프로세스 보다 우수하다.
