## 운영체제 들어가기
### 운영체제 개요

- 개인용 컴퓨터: Windows, MacOS
- 대형 컴퓨터나 서버: 유닉스, 리눅스
- 스마트폰 태블릿: 안드로이드, ios
- 내비게이션,스마트워치, 냉장고, 세탁기: 임베디드 운영체제


> 💡 컴퓨터는 운영체제가 있어야 동작하는가?
> - 동작은 할 수 있지만 운영체제 없으면 처음 설계한 대로만 동작할 뿐 다른 기능 추가 불가
> - ex) 유선 전화는 전화 기능이 있지만 스마트폰은 다양한 기능 활용 가능


### 운영체제가 하는 일

1. 프로세스 관리
- 노래들으면서 게임해도 동작 가능.
- 게임을 하고 있으면 키보드와 마우스는 게임에만 반응하고 다른 프로그램은 백그라운드에서 동작해야한다. 만약 그렇지 않으면 다른 프로세스가 cpu를 독차지 해서 정상적으로 동작하지 않을 수있음
2. 메모리 관리
- 여러 프로그램을 동시에 실행하기 때문에 동시에 관리
3. 하드웨어 관리
- 사용자의 하드웨어의 직접적인 접근 막음(사용자가 악의적으로 공격을 할 수 있기 때문)
4. 파일 시스템 관리

### 운영체제의 역사

>💡 컴퓨터 시스템 개발자들의 고민
> - 어떻게 CPU 사용성을 향상시킬까?
> - 어떻게 오퍼레이터와 프로그래머 사이에서 낭비되는 시간 줄일 수 있을까?


- 1940: 에니악
    - 입출력 속도가 매우 느리고 무거움
- 1950 초: 논리회로를 작은 크기로 만든 직접회로 → 현대적인 컴퓨터 형상 만들어짐
- 1950 중후반
    - 오퍼레이터를 통해 cpu에 전달하는 과정에서 생기는 오버헤드 문제 해결을 위해 오퍼레이터에 여러개의 작업을 한번에 요청하는 “싱글스트림 배치시스템” 도입
    - 당시에 입출력 시 CPU 사용할 수 없었는데 입출력 담당하는 I/O 디바이스 컨트롤러를 만들어 입출력 중에도 CPU가 계산할 수 있도록 만듦. I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 인터럽트를 보내 CPU가 작업을 처리할 수 있도록 함.
    - 입출력에도 CPU를 기다려야 하는 작업 있는데, 입력은 CPU의 연산을 기다려야하기 때문에 CPU 사용률이 떨어짐.(싱글 스트림 배치 시스템의 한계)
- 1960
    - 싱글 스트림 배치 시스템 해결: 프로그램을 하나씩 처리하는게 아니라 여러 프로그램을 번갈아가면서 실행해 사용자에게는 동시에 실행하는 것처럼 보임(시분할 시스템)
    - 당시 컴퓨터가 비싸서 여러 터미널을 통해 여러 사용자가 컴퓨터에 접근.
        - 이 때문에 개인적인 파일을 저장하기도 해서 ‘파일시스템 등장’
    - UNIX
        - 동시에 여러 개 실행시키는 ‘멀티프로그래밍’
        - 여러 사용자 지원하는 ‘다중 사용자’
        - ‘파일시스템’
    - 다른 프로그램의 메모리에 접근하거나 os의 메모리에 접근하게 되는 경우 문제가 생김
        - 여러 프로그램이 실행되니까 하드웨어 적으로 ‘베이스 레지스터’를 추가해서 시작 주소 저장하고 모든 프로그램은 0번 주소부터 시작한다고 가정
- 1970
    - 저렴해져서 개인이 소유하기 쉬워짐

### 운영체제의 구조

핵심: 커널

- 프로세스와 메모리, 저장장치를 관리하는 핵심적 기능
- 사용자는 인터페이스(GUI/CLI)를 통해서만 커널에 접근할 수 있음
    - GUI: 시각적 인터페이스
    - CLI: 텍스트를 이용해 커널과 상호작용
- 커널은 사용자로부터 자신을 보호하기 위한 ‘시스템 콜’ 이라는 인터페이스를 가지고 있음
    - 시스템 콜이 없으면? 중요한 데이터나 다른 데이터가 저장된 공간을 덮어쓸 수 있음
    - 시스템 콜을 사용하면? 운영체제가 알아서 하드디스크의 빈 공간에 저장하게 됨
- 하드웨어를 제작한 제조사에서 드라이버를 제공해서 이를 설치해서 사용해야 함.

### 컴퓨터 하드웨어와 구조
프로그램 내장 방식의 '폰 노이만 구조': 프로그램을 메모리(ram)에 내장
- 기존에 하드웨어와 프로그램 연결돼있었으나, cpu와 ram을 두고 이 사이를 버스로 연결하는 방식으로 변경
- 버스: 데이터를 전달하는 통로, 장치 간에 데이터를 전송하는 담당
- 메인보드: 다른 하드웨어를 연결하는 장치
  - 버스가 데이터 전송 담당
  - 폰 노이만 구조니까 cpu와 메모리 필수적
  - 하드디스크 연결 단자에는 하드디스크 꽂아줌
  - 그래픽 카드 연결 단자에는 그래픽 카드 꽂아줌
  - 출력 단자에 모니터 선 꽂으면 모니터 작동하게 됨
  - usb 단자에 마우스와 키보드 연결
  - 사운드 단자에 스피커 연결
- 중앙처리 장치, cpu(Central Processing Unit)
  - 산술 논리 연산 장치(ALU): 데이터 연산 장치
  - 제어 장치(Control Unit): 모든 장치들의 동작 지시 및 제어 장치
  - 레지스터(Register): 계산을 위해 임시로 보관하는 장치
- 메모리 종류
  - RAM: 랜덤으로 데이터 읽어도 저장된 위치와 상관없이 읽는 속도 같음, 메인 메모리, 전력 끊기면 날아감
  - ROM: 전력이 끊겨도 데이터 보관할 수 있지만, 한번 저장하면 변경x, 부팅과 관련된 정보를 주로 저장

### 컴퓨터 부팅 과정
- 부팅 시 ROM에 저장된 BIOS 실행
  - 주요 하드웨어에 문제가 있는지 확인, 문제 없으면 부트로드를 메모리에 가져와서 실행
  - 만약 운영체제가 여러개면 선택 가능, 운영체제를 메모리로 불러와 바탕화면 보임
  - 실행되는 모든 응용프로그램은 메모리에 올라와서 운영체제가 관리

### 인터럽트
cpu는 입출력작업 들어오면 입출력 관리자에게 입출력 명령 내림
- 폴링 방식: cpu가 입출력 관리자에게 주기적으로 확인해야 함
- 인터럽트: 폴링 방식 해결, 입출력 완료됐을 때 cpu에게 신호, cpu는 다른 작업하다가 신호를 받으면 인터럽트 서비스 루틴(ISR)을 실행시켜 작업 완료
  - 인터럽트 서비스 루틴(ISR): 특정 인터럽트가 들어오면 그 인터럽트 처리하는 함수(비동기적으로 동작해서 성능 이점)
  - 인터럽트 방식
    - 하드웨어 인터럽트: 입출력 인터럽트
    - 소프트웨어 인터럽트: 사용자 프로그램에서 발생한 인터럽트
      - ex) 0으로 나누는 명령어, 유효하지 않은 메모리 접근

###  프로그램과 프로세스
- 프로그램: 하드디스크와 같은 저장장치에 저장된 명령문의 집합체(.exe) -> 수동적
- 프로세스: 실행중인 프로그램(저장중인 프로그램이 메모리에 올라갔을 때) -> 능동적
  - 프로세스는 Code, data, heap, stack 영역으로 나뉨
  - code: 자신을 실행하는 코드
  - data: 전역과 스태틱 변수
  - heap: 프로그래머가 런타임 시 할당할 수 있는 메모리 공간
  - stack: 지역 변수와 함수 호출 시 필요한 정보

- 컴파일 과정
  > 코드 -> 전처리기(매크로로 저장한 숫자 치환, 필요한 파일 불러옴) -> .i 파일 -> 컴파일러(기계어와 가까운 어셈블리어로 변경) -> .s 파일 -> 어셈블러 -> 기계어 -> 링커(라이브러리, 소스코드와 연결) -> .exe


### 멀티 프로그래밍과 멀티 프로세싱
- 유니프로그래밍: 메모리에 프로세스 하나
- 멀티프로그래밍: 메모리에 프로세스 여러개
- 멀티프로세싱: 메모리 관점x cpu 관점으로 정의해 cpu가 여러 프로세스를 처리하는 것
- 오늘 날: 멀티프로그래밍 + 멀티프로세싱(시분할 시스템)
- 스와핑: 프로세스를 저장장치에 올려서 필요한 걸 그때그때 저장장치와 메모리에서 옮겨가며 실행하는 것

### PCB(Process Control Block)
- 프로세스: 프로그램이 메모리에 올라가 실행 중인 상태
- 운영체제는 프로세스가 만들어질 때 프로세스의 정보를 저장하는 'PCB' 생성
  - PCB는 연결리스트 자료구조(프로세스 종료시 연결리스트에서 제거)
  - PCB 구조
    - 포인터: 부모와 자식 프로세스에 대한 포인터, 할당된 자원에 대한 포인터, 프로세스의 한 상태에서 다른 상태로 전환 될 때 저장하는 포인터
    - 프로세스 상태: 현재 프로세스의 5가지 상태(생성, 준비, 실행, 대기, 완료)
    - 프로세스 ID: 식별자
    - 프로그램 카운터: 다음에 실행할 명령어(시분할 시스템에 의해 프로세스가 번갈아가며 실행되기 때문)
    - 레지스터 정보: 원래 값 복구하기 위해 저장되는 정보
    - 메모리 관련 정보: 프로세스가 메모리에 있는 위치 정보(경계 레지스터 값등 저장)
    - cpu 스케줄링 정보: cpu 스케줄링 우선순위, 최종 실행시간, 점유시간

### 프로세스 상태
- 생성: pcb를 생성하고 메모리에 프로그램 적재를 요청한 상태
- 준비: 메모리 적재 허락맡으면 cpu 할당을 위해 기다리는 상태(cpu 스케줄러에 의해 할당)
- 실행: 준비 상태에 있는 프로세스가 cpu 스케줄러에 의해 cpu 할당받아 실행되는 상태(cpu 개수만큼 실행 중)
  - 준비상태로 돌아갈 때(인터럽트)
- 대기: 프로세스가 입출력 요청하면 입출력 완료될 때까지 기다리는 것(이때는 다른 프로세스에게 자원 할당) -> 완료되면 준비상태
- 완료: 프로세스 종료된 상태

### 컨텍스트 스위칭
- 프로세스 실행하는 중에 다른 프로세스를 실행하기 위해 프로세스의 상태를 PCB에 저장하고 다른 프로세스 상태 값으로 저장하는 것
- 프로세스 상태, 프로그램 카운터, 각종 레지스터 값 등 저장
- 순서
  - 프로세스 점유시간 초과하면 운영체제가 인터럽트 발생
  - cpu의 레지스터 값 등 pcbA에 저장
  - 실행시킬 pcb 참고해서 프로그램 카운터부터 pcbB 명령어 시작

### 프로세스 생성과 종료
- 코드 영역과 데이터 영역 메모리에 로드, 빈스택과 힙 올려 공간 확보
- pcb 만들어 초기화
- 위의 과정은 0번 프로세스가 생성될 때 딱 한번만 실행
- 이후에는? fork() 함수로 모두 0번 프로세스 복사(복사하는게 더 빠르기 때문)-> 자식프로세스, 0번 프로세스는 부모 프로세스
  - pcb와 코드,데이터,힙,스택 모두 복사
  - 원하는 함수는 exec() 함수를 실행시켜, 자식 프로세스의 값을 원하는 값으로 덮어쓰게 됨(부모 프로세스와 다르게 동작)

- 종료시 자식 프로세스 exit()함수 호출해서 부모 프로세스에게 자기 프로세스 종료됐다는 것을 알림
  - 좀비 프로세스: 자식 프로세스에 비정상적으로 종료되거나 부모 프로세스 먼저 종료돼 계속 메모리에 올라온 프로세스

### 쓰레드
프로세스: 자원할당 단위 -> 프로세스가 많아지면 code,date,heap,stack 영역 만들어줘야돼서 무거워짐
- 프로세스끼리 통신하려면 IPC 사용해야 됨 -> 비용 많이 듬
쓰레드: 프로세스 내에 존재, pcb, code, data, heap 영역 공유(스택은 공유x)
- 쓰레드 ID 부여, 쓰레드를 관리하기 위한 TCB
- 작업 처리의 단위
- 차이
  - 프로세스 하나 문제 생겨도 다른 프로세스에는 지장x but 스레드는 하나의 프로세스에 문제가 생기면 모든 스레드에 문제가 생김
  - 프로세스는 IPC를 이용해야해서 오버헤드가 생기고 속도 느리지만 쓰레드는 오버헤드 적다.
  - 쓰레드는 공유되는 공간에서 문제가 생길 수 있다.(동기화)
