### 운영체제 개요

- 개인용 컴퓨터: Windows, MacOS
- 대형 컴퓨터나 서버: 유닉스, 리눅스
- 스마트폰 태블릿: 안드로이드, ios
- 내비게이션,스마트워치, 냉장고, 세탁기: 임베디드 운영체제


> 💡 컴퓨터는 운영체제가 있어야 동작하는가?
> - 동작은 할 수 있지만 운영체제 없으면 처음 설계한 대로만 동작할 뿐 다른 기능 추가 불가
> - ex) 유선 전화는 전화 기능이 있지만 스마트폰은 다양한 기능 활용 가능


### 운영체제가 하는 일

1. 프로세스 관리
- 노래들으면서 게임해도 동작 가능.
- 게임을 하고 있으면 키보드와 마우스는 게임에만 반응하고 다른 프로그램은 백그라운드에서 동작해야한다. 만약 그렇지 않으면 다른 프로세스가 cpu를 독차지 해서 정상적으로 동작하지 않을 수있음
2. 메모리 관리
- 여러 프로그램을 동시에 실행하기 때문에 동시에 관리
3. 하드웨어 관리
- 사용자의 하드웨어의 직접적인 접근 막음(사용자가 악의적으로 공격을 할 수 있기 때문)
4. 파일 시스템 관리

### 운영체제의 역사

>💡 컴퓨터 시스템 개발자들의 고민
> - 어떻게 CPU 사용성을 향상시킬까?
> - 어떻게 오퍼레이터와 프로그래머 사이에서 낭비되는 시간 줄일 수 있을까?


- 1940: 에니악
    - 입출력 속도가 매우 느리고 무거움
- 1950 초: 논리회로를 작은 크기로 만든 직접회로 → 현대적인 컴퓨터 형상 만들어짐
- 1950 중후반
    - 오퍼레이터를 통해 cpu에 전달하는 과정에서 생기는 오버헤드 문제 해결을 위해 오퍼레이터에 여러개의 작업을 한번에 요청하는 “싱글스트림 배치시스템” 도입
    - 당시에 입출력 시 CPU 사용할 수 없었는데 입출력 담당하는 I/O 디바이스 컨트롤러를 만들어 입출력 중에도 CPU가 계산할 수 있도록 만듦. I/O 디바이스 컨트롤러는 입출력 작업이 끝나면 인터럽트를 보내 CPU가 작업을 처리할 수 있도록 함.
    - 입출력에도 CPU를 기다려야 하는 작업 있는데, 입력은 CPU의 연산을 기다려야하기 때문에 CPU 사용률이 떨어짐.(싱글 스트림 배치 시스템의 한계)
- 1960
    - 싱글 스트림 배치 시스템 해결: 프로그램을 하나씩 처리하는게 아니라 여러 프로그램을 번갈아가면서 실행해 사용자에게는 동시에 실행하는 것처럼 보임(시분할 시스템)
    - 당시 컴퓨터가 비싸서 여러 터미널을 통해 여러 사용자가 컴퓨터에 접근.
        - 이 때문에 개인적인 파일을 저장하기도 해서 ‘파일시스템 등장’
    - UNIX
        - 동시에 여러 개 실행시키는 ‘멀티프로그래밍’
        - 여러 사용자 지원하는 ‘다중 사용자’
        - ‘파일시스템’
    - 다른 프로그램의 메모리에 접근하거나 os의 메모리에 접근하게 되는 경우 문제가 생김
        - 여러 프로그램이 실행되니까 하드웨어 적으로 ‘베이스 레지스터’를 추가해서 시작 주소 저장하고 모든 프로그램은 0번 주소부터 시작한다고 가정
- 1970
    - 저렴해져서 개인이 소유하기 쉬워짐

### 운영체제의 구조

핵심: 커널

- 프로세스와 메모리, 저장장치를 관리하는 핵심적 기능
- 사용자는 인터페이스(GUI/CLI)를 통해서만 커널에 접근할 수 있음
    - GUI: 시각적 인터페이스
    - CLI: 텍스트를 이용해 커널과 상호작용
- 커널은 사용자로부터 자신을 보호하기 위한 ‘시스템 콜’ 이라는 인터페이스를 가지고 있음
    - 시스템 콜이 없으면? 중요한 데이터나 다른 데이터가 저장된 공간을 덮어쓸 수 있음
    - 시스템 콜을 사용하면? 운영체제가 알아서 하드디스크의 빈 공간에 저장하게 됨
- 하드웨어를 제작한 제조사에서 드라이버를 제공해서 이를 설치해서 사용해야 함.