### CPU스케쥴링 개요
- 필수장치: CPU, 메모리
- 주변장치: 마우스,키보드

프로그램 실행 시키면 메모리에 프로세스 생성, 각 프로세스에는 1개 이상의 쓰레드
프로세스들은 CPU 차지하기 위해 운영체제 명령 기다림
운영체제가 모든 프로세스에게 CPU 할당/해제하는데 이를 'CPU 스케줄링'이라고 함

1. 어떤 프로세스에게 CPU 리소스 할당하는가?
2. CPU 할당받은 프로세스가 얼마의 시간동안 CPU 사용하는가?
- 시분할 처리방식: 여러 프로세스에게 짧은 시간동안 돌아가면서 프로세스 할당
-> 위의 두가지가 컴퓨터 성능에 큰 영향 끼침
CPU 할당받아 실행하는 것: CPU BURST
입출력 작업: I/O BURST

### 다중큐
준비상태와 대기상태 프로세스는 '큐'로 관리 됨
큐: FIFO 구조의 자료구조

실행상태에서 준비상태로 돌아갈 때 운영체제는 해당 프로세스 우선순위 보고 그에 맞는 준비큐에 넣음
준비상태에 있는 프로세스들 중에 적당한 프로레스 골라 실행시킴

실행상태에서 대기상태로 오게되면 I/O 작업 종류에따라 분류된 큐에 들어감
대기상태에서 벗어나면(I/0 작업이 끝나면) 다시 꺼내감
큐에 프로세스 들어가는 것 보다는 PCB가 들어간다는 표현이 정확

준비상태의 다중큐 참고해 어떤 프로세스 실행시킬지 정함
실행 중인 프로세스에서 I/O 작업이 발생하면 해당 I/O 작업 종류별로 나뉜 대기 큐에 들어감


### 스케쥴링 목표
1. 리소스 사용률(CPU 사용률 높이는 것 OR I/O 디바이스 사용률 증가)
2. 오버헤드 최소화(컨텍스트 스위칭 많이 일어나면 X)
3. 여러 프로세스에게 공평하게 자원 할당
- 어떤 프로그램이냐에 따라 어떤 프로세스가 우선순위가 될지가 다름
4. 처리량
- 같은 시간내 더 많은 처리
5. 대기시간하는 시간 짧은 것
6. 응답시간: 사용자의 요청에 얼마나 빠르게 반응 하는지

TRADE OFF
처리량: 높이기 위해 하나의 프로세스에 CPU 오래 할당
응답시간: CPU 할당 시간 줄이기
> 사용자가 사용하는 시스템에 따라 목표를 다르게 설정
> 일반적으로는 밸런스를 유지하는게 중요

### 스케쥴링 알고리즘 : FIFO
FIRST IN FIRST OUT 약자: 스케쥴링 큐에 들어온 순서대로 자원 할당(무조건 먼저 도착한 사람이 먼저 작업 끝나야 함)
- 장점: 단순, 직관적
- 단점: 한 프로세스가 완전히 끝나야 다음 프로세스가 실행(작업 기다려야하는 시간 김)
-- I/O 작업 있을 때 CPU 쉬고있기 때문에 CPU 사용률 떨어짐

스케줄링 성능: 평균 대기시간으로 평가(프로세스 여러개 시작될 때 실행까지 대기하는 평균 시간)
> 즉, 프로세스 길이에 따라 평균 대기시간이 천차만별이기에 현재는 잘 쓰이지 않음

### 스케쥴링 알고리즘 : SJF(Shortest job first)
작업의 순서에 따라 평균 대기 시간이 크게 달라질 수 있다.
> IDEA
> burst time(실행 시간)이 짧은게 먼저 실행되면 평균 대기시간이 짧아진다
> burst time(실행 시간)이 긴게 먼저 실행되면 평균 대기시간이 길어진다.
즉, 짧은 작업 먼저 수행하는 알고리즘

문제
1. 어떤 프로세스가 얼마나 실행될 지 예측 불가(프로세스 종료 시간 예측 불가능)
2. burst time이 긴 프로세스는 아주 오랫 동안 실행되지 않을 수도 있음(burst time이 길면 밀려남)

### RR(Round Robin)
> FIFO 단점: 먼저 들어온 프로세스 작업이 다 끝나야 다음 작업이 실행 됨
> CPU 할당 시간 지나면 강제로 다른 프로세스에 일정시간만큼 작업 할당
> 강제로 CPU 할당 뺏긴 프로세스는 큐의 맨 뒤로 밀려남

프로세스에 할당하는 일정시간: 타임 슬라이스, 타임 퀀텀
-> 타임 슬라이스 값에 따라 성능이 크게 달라짐
-> 아주 작게 설정하면 동시에 동작하는 것처럼 보임 but 컨텍스트 스위칭 양이 많아짐

### MLFQ(Multi level feedback queue)
round robin 알고리즘의 업그레이드 버전

cpu 연산만 하는 프로세스:cpu bound process
- 중요하게 생각하는 것: cpu 사용률과 처리량
io 연산이 대부분인 프로세스: io bound process
- 중요하게 생각하는 것: 응답 시간

> 타임 슬라이스를 길게 하면 cpu bound process 입장에서는 좋지만(cpu 사용률 100%)
> 짧게하면 io bound process 입장에서 좋음(i/o사용률 90%) -> 짧게하는게 좋다는 결론이 내림
> 후자의 경우 컨텍스트 스위칭이 생기긴 하지만, 별 문제 없이 실행되는 것처럼 보임
> mlfq의 경우에는 둘을 구분해서 시간 할당
> 우선순위 별 큐를 이용해서 우선순위가 높으면 타임 슬라이스 짧게, 우선순위가 낮으면 타임 슬라이스 길게
> 오늘날은 대부분 mlfq

### 프로세스 간 통신
프로세스 간 통신을 할때도 있음
1. 한 컴퓨터 내에서 프로세스 간 통신(파일과 파이프 이용)
   - 운영체제가 생성한 파이프를 통해 읽고 쓰는 것
2. 스레드 이용
- 한 프로세스 내 쓰레드간 통신 방법: 전역변수나 힙 이용하면 통신 가능
3. 네트워크 이용
- 운영체제가 제공하는 소켓통신이나 RPC 이용

### 공유자원과 임계영역
공동 변수나 파일: 공유자원(여러 프로세스가 공유)
- 접근 순서에 따라 결과가 달라질 수 있는 문제가 있음
- 컨텍스트 스위칭으로 시분할 처리: 어떤 프로세스가 먼저 실행될지 모름(연산과정 예측 불가)

공유자원을 여러 프로세스가 동시에 사용하면 안되는 영역: 임계 구역
공유자원을 사용하기 위해 경쟁하는 것: 경쟁조건

임계 구역 문제 해결하기 위해: 상호배제 필요

상호배제 요구사항
1. 임계영역엔 동시의 하나의 프로세스만 접근
2. 여러 요청에도 하나의 프로세스의 접근만 허용
3. 임계구역에 들어간 프로세스는 빠르게 나와야한다.

### 세마포어
상호배제 메커니즘
- 방: 공유자원
- 공유자원을 쓰기위해 기다리는 것: 대기큐
- 방에 들어가기 위한 열쇠: 세마포어

단점: wait()과 signal() 함수 잘못호출 할 수 있음

### 모니터
세마포어의 단점 해결한 상호배제 매커니즘
- 운영체제가 처리x 프로그래밍 언어차원에서 지원
- 세마포어 처럼 함수를 이용해 임계영역에 감싸지 않아도 돼서 편하고 안전하게 코딩 할 수 있음
- ex) synchronized

### 교착상태(데드락)
여러 프로세스가 서로 다른 프로세스가 끝날때까지 기다리면서 아무도 작업 진행 못하는 상태
자원을 공유하지 않으면? 교착상태도 발생하지 않음

- 예시
식사하는 철학자: 3명이 밥먹으려면 포크가 2개씩 있어야하는데 포크 3개가 있을때, 각자 한개씩 포크를 쥐게되면?
아무도 식사를 못하는 상황

- 교착상태 조건
1. 상호배제: 어떤 프로세스가 한 리소스 점유하면 그 리소스는 다른 프로세스에게 공유되면 안됨
2. 비선점: 다른 프로세스의 자원을 뺏을 수 없어야 함
3. 점유와 대기: 리소스 A를 가지고 있는 상황에서 리소스 B를 기다리고 있을 때
4. 원형 대기: 프로세스 간 관계가 원형 이루고 있을때(서로가 서로의 자원을 원하는 경우)

-> 예방은 제약이 많고 불가능

### 교착상태 해결
1. 교착상태 회피: 어느정도 자원할당해야 교착상태가 발생하는지 확인해서 발생하지 않는 만큼 자원 할당
- 전체자원과 할당된 자원으로 나누어 안정상태/불안정상태로 나눔
- ex) 은행원 알고리즘: 누구에게도 돈을 빌려주지 못하고 받지 않는 교착상태 -> 대출 가능한 상황인지 확인하고 빌려줘야 함(상황 능력 고려)
> 시스템은 전체 자원 수 알고있어야 함, 프로세스들은 최대 요구자원을 운영체제에게 알려줘야 함
>  안정상태: 요청이 예상되는 자원 중 사용가능한 자원보다 적거나 같은 경우 그 프로세스에게 자원 할당
> 불안정상태: 사용가능한 자원보다 모든 프로세스의 요청이 예상되는 자원이 많을 때
> -> 불안정 상태에 빠지지 않도록 해야함

2. 타이머를 이용해 교착상태 검출(가벼운 교착상태 검출): 특정 시간이 지나면 교착상태 해결
- 타임아웃(마지막 저장된 체크포인트로 돌아감)
3. 무거운 교착상태 검출: 자원할당 그래프를 이용해 운영체제에서 프로세스가 어떤 자원 사용하는지 보고 해결
- 순환구조 생겼을 때 그래프를 보고 검출해서 교착상태 일으킨 프로세스 강제종료하고 체크포인트로 롤백
- 운영체제가 자원할당 그래프를 유지해야하기에 오버헤드가 생기지만, 억울하게 종료되는 프로세스 발생하지 않음