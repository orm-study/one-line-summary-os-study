-   
    ### 섹션 3. CPU 스케줄링
    
    ### 1. CPU와 프로세스
    
    - **CPU(중앙 처리 장치)**: 프로그램을 실행할 때 프로세스가 메모리에 생성되고, 각 프로세스는 1개 이상의 스레드를 포함합니다. 이 프로세스들은 CPU 리소스를 차지하기 위해 운영체제의 명령을 기다립니다.
    - **CPU 스케줄링**: 운영체제는 모든 프로세스에게 CPU를 할당하거나 해제하는 작업을 수행합니다.
    
    ### 2. CPU 스케줄러의 고려 사항
    
    1. **어떤 프로세스에게 CPU를 할당할 것인가?**
        - 메모리에는 수많은 프로세스가 존재하며, 이 중 어떤 프로세스가 우선순위가 높은지 결정해야 합니다.
    2. **CPU를 할당받은 프로세스가 얼마나 CPU를 사용할 것인가?**
        - 시분할 처리방식으로 여러 프로세스가 짧은 시간 동안 돌아가며 CPU를 사용합니다.
    
    ### 3. CPU와 I/O Burst
    
    - **CPU Burst**: 프로세스가 CPU를 할당받아 작업을 수행하는 시간.
    - **I/O Burst**: 입출력 작업이 이루어지는 시간.
    
    ### 4. 준비와 대기 상태 관리
    
    - 프로세스의 상태는 큐(Queue)라는 자료구조로 관리됩니다. 큐는 먼저 들어온 프로세스가 먼저 처리되는 방식으로 작동합니다.
    - **큐와 스택의 차이**: 큐는 마트 계산대와 같이 먼저 들어온 것이 먼저 처리되는 구조(FIFO), 스택은 후입선출(LIFO) 방식입니다.
    
    ### 5. CPU 스케줄링의 목표
    
    1. **리소스 사용률**:
        - CPU 사용률과 I/O 디바이스의 사용률을 높이는 것이 중요합니다.
    2. **오버헤드 최소화**:
        - 스케줄링을 위한 계산이 너무 복잡하지 않도록 하며, 컨텍스트 스위칭이 너무 자주 발생하지 않도록 합니다.
    3. **공평성**:
        - 모든 프로세스에게 공평하게 CPU를 나누어야 하지만, 특정 시스템에서는 안정성 등을 우선할 수 있습니다.
    4. **처리량**:
        - 같은 시간 내에 더 많은 작업을 처리하는 것이 목표입니다.
    5. **대기 시간 최소화**:
        - 작업을 요청하고 실제 작업이 이루어지기 전까지의 대기 시간을 줄이는 것이 중요합니다.
    6. **응답 시간**:
        - 대화형 시스템에서 사용자의 요청에 얼마나 빨리 반응하는지가 중요한 요소입니다.
    
    ### 6. CPU 스케줄링 알고리즘
    
    1. **FIFO (First In First Out)**
        - 들어온 순서대로 CPU를 할당받아 작업을 처리합니다.
        - 장점: 단순하고 직관적임.
        - 단점: 한 프로세스가 끝나야 다음 프로세스가 처리되므로 비효율적일 수 있습니다.
    2. **SJF (Shortest Job First)**
        - CPU Burst가 짧은 프로세스부터 먼저 실행하는 방식.
        - 문제점: 각 프로세스의 Burst Time을 정확히 예측하기 어렵고, 긴 Burst Time을 가진 프로세스가 계속 지연되는 불공평한 상황이 발생할 수 있음.
    3. **RR (Round Robin)**
        - 각 프로세스에게 일정 시간(타임 슬라이스)을 할당하여 처리하는 방식.
        - 단점: 컨텍스트 스위칭이 자주 발생하면 오버헤드가 증가할 수 있음.
        - 타임 슬라이스가 너무 크면 응답 속도가 느려지고, 너무 작으면 오버헤드가 커집니다.
    4. **MLFQ (Multi Level Feedback Queue)**
        - 우선순위가 다른 여러 큐를 사용하여 CPU 사용률과 응답 속도를 동시에 고려한 스케줄링.
        - CPU 사용이 많은 프로세스는 낮은 우선순위로 이동하며, 최종적으로 FIFO 방식처럼 동작합니다.
    
    ### 7. 스케줄링 성능 평가
    
    - **평균 대기 시간**: 모든 프로세스가 실행된 시간의 평균을 계산하여 스케줄링의 성능을 평가합니다.
    
    ---
    
    이와 같은 CPU 스케줄링 기법은 각 시스템의 요구사항에 맞춰 선택되며, 모든 목표를 완벽하게 충족하기는 어렵습니다.
    
    ### 섹션 4. 프로세스 동기화
    
    ### 프로세스 간 통신
    
    프로세스는 독립적으로 실행되기도 하지만, 다른 프로세스와 통신할 수 있습니다. 통신은 한 컴퓨터 내에서 이루어지거나 네트워크를 통해 다른 컴퓨터와 진행될 수 있습니다.
    
    1. **한 컴퓨터 내에서 프로세스 간 통신 방법**
        - **파일**: 하나의 파일을 사용해 데이터를 읽고 씁니다.
        - **파이프**: 운영체제가 생성한 파이프를 이용해 데이터를 주고받습니다.
    2. **쓰레드를 이용한 방법**
        - 하나의 프로세스 내에서 쓰레드 간 통신이 가능합니다. 이때 **코드**, **데이터**, **힙** 영역은 공유되지만 **스택**은 쓰레드 고유의 영역입니다. 전역 변수나 힙을 통해 쓰레드 간 통신이 가능합니다.
    3. **네트워크를 이용한 방법**
        - **소켓**: 운영체제가 제공하는 소켓을 사용해 통신합니다.
        - **RPC(원격 프로시저 호출)**: 네트워크 상의 다른 컴퓨터와 통신할 때 사용됩니다.
    
    ### 공유 자원과 동기화 문제
    
    프로세스 간 통신에서 **공유 자원**을 사용할 때, 각 프로세스의 접근 순서에 따라 결과가 달라질 수 있습니다. 또한, 시분할 처리를 하는 컨텍스트 스위칭으로 인해 예측 불가능한 결과가 발생할 수 있으며, 이를 **동기화 문제**라 합니다.
    
    ### 임계 구역 문제
    
    **임계 구역**은 여러 프로세스가 동시에 접근하면 안 되는 영역을 의미합니다. **경쟁 조건**은 여러 프로세스가 공유 자원에 접근하려고 경합하는 상황을 뜻합니다.
    
    임계 구역 문제를 해결하기 위한 요구 사항:
    
    1. **상호 배제(Mutual Exclusion)**: 임계 구역에는 한 번에 하나의 프로세스만 접근할 수 있습니다.
    2. 여러 프로세스가 동시에 요청해도 하나의 프로세스만 접근이 허용됩니다.
    3. 임계 구역에 들어간 프로세스는 가능한 한 빠르게 작업을 마쳐야 합니다.
    
    ### 세마포어(Semaphore)
    
    **세마포어**는 동기화 문제를 해결하는 데 가장 중요한 개념입니다. 세마포어는 **정수형 변수**로, 프로세스 간 자원 접근을 동기화하는데 사용됩니다.
    
    세마포어의 주요 용도:
    
    1. **자원 접근 동기화**: 여러 프로세스가 공유 자원에 접근할 때 발생하는 문제를 방지합니다.
    2. **생산자-소비자 문제**: 생산자와 소비자가 같은 자원을 사용할 때 작업을 동기화합니다.
    3. **임계 구역 보호**: 여러 스레드가 동시에 임계 구역에 진입하지 않도록 합니다.
    
    세마포어의 장점:
    
    - **경쟁 상태 방지**: 공유 자원 사용을 안전하게 보장합니다.
    - **동기화 가능**: 여러 스레드나 프로세스의 실행 순서를 제어할 수 있습니다.
    
    세마포어의 단점:
    
    - **교착 상태(Deadlock)**: 여러 세마포어를 사용할 때, 교착 상태가 발생할 수 있습니다.
    - **기아 상태(Starvation)**: 일부 프로세스가 자원에 계속 접근하지 못하고 대기 상태에 빠질 수 있습니다.
    
    ### 모니터(Monitor)
    
    **모니터**는 프로그래밍 언어 차원에서 동기화를 지원하는 방식으로, 운영체제가 아닌 언어 자체에서 처리됩니다. 대표적으로 자바에서 **모니터**를 지원합니다.
    
    모니터와 세마포어 비교:
    
    - 세마포어는 프로그래머가 직접 관리해야 하지만, 모니터는 내부에서 대기 및 신호 전달을 처리하여 동기화 작업을 간소화합니다.
    
    모니터의 특징:
    
    1. **공유 자원 보호**: 모니터는 특정 공유 자원에 대한 접근을 제어하여, 한 번에 하나의 프로세스나 스레드만 자원에 접근하도록 보장합니다.
    2. **내장된 동기화 기법**: 자원을 사용할 수 없을 때, 스레드나 프로세스를 자동으로 대기시키고, 자원이 사용 가능해지면 대기 중인 스레드를 자동으로 재개시킵니다.
    3. **임계 구역 관리**: 모니터는 임계 구역을 설정해 동시 접근을 방지합니다.
    
    ### 섹션 5. 데드락(교착상태)
    
    - *교착상태(데드락)**란, 여러 프로세스가 서로 다른 프로세스가 사용하는 자원을 기다리면서 아무도 작업을 진행하지 못하는 상황을 의미합니다.
    
    ### 교착상태의 필요 조건
    
    교착상태가 발생하기 위한 4가지 조건은 다음과 같습니다:
    
    1. **상호 배제(Mutual Exclusion)**
        
        한 프로세스가 리소스를 점유하면, 그 리소스는 다른 프로세스와 공유되지 않아야 합니다.
        
    2. **비선점(No Preemption)**
        
        프로세스 A가 리소스를 점유하고 있으면, 프로세스 B가 이를 강제로 가져갈 수 없습니다.
        
    3. **점유와 대기(Hold and Wait)**
        
        프로세스는 최소 하나의 리소스를 점유한 상태에서, 다른 리소스를 기다려야 합니다.
        
    4. **원형 대기(Circular Wait)**
        
        점유와 대기를 하는 프로세스들이 원형 관계를 이루며, 서로의 리소스를 기다리는 상태입니다.
        
    
    이 중 하나라도 충족되지 않으면 교착상태는 발생하지 않습니다.
    
    ### 교착상태 해결 방법
    
    교착상태를 예방하기는 매우 비효율적이기 때문에, 이를 회피하거나 해결하는 방법들이 연구되었습니다.
    
    1. **교착상태 회피 (Deadlock Avoidance)**
        - **은행원 알고리즘**과 같은 방법을 사용하여 자원을 할당할 때 교착상태 발생 가능성을 사전에 분석합니다. 자원이 충분히 안정된 상태에서만 할당되며, 자원의 할당 상태는 **안정 상태(Safe State)**와 **불안정 상태(Unsafe State)**로 구분됩니다.
        - **안정 상태**에서는 교착상태가 발생하지 않으며, **불안정 상태**는 교착상태의 가능성이 있지만 반드시 발생하는 것은 아닙니다.
    
    ### 은행원 알고리즘의 개요
    
    - **시스템의 총 자원**: 운영체제는 전체 자원의 수를 파악하고 있습니다.
    - **최대 요구 자원**: 프로세스는 각자 필요로 하는 자원의 최대치를 운영체제에 미리 알려줍니다.
    - 은행원 알고리즘은 각 프로세스가 요청할 자원의 수를 미리 예상하고, 자원의 할당 가능 여부를 판단합니다.
    
    은행원 알고리즘은 교착상태를 회피할 수 있지만, 비용이 크고 비효율적입니다.
    
    1. **교착상태 검출 및 해결**
    교착상태가 발생하면 이를 검출하고 해결하는 방법도 연구되었습니다.
        1. **가벼운 교착상태 검출**
            - **타이머**: 프로세스가 일정 시간 동안 작업을 진행하지 않으면 교착상태가 발생한 것으로 간주하고 해결합니다.
            - **체크포인트 롤백**: 작업 진행 중 주기적으로 상태를 저장하고, 교착상태가 발생하면 저장했던 지점으로 롤백합니다. 이는 게임에서 롤백하는 매커니즘과 유사합니다.
        2. **무거운 교착상태 검출**
            - **자원 할당 그래프**: 현재 운영체제에서 어떤 프로세스가 어떤 자원을 사용하는지 감시하고, 교착상태가 발생하면 이를 해결합니다.
            - 자원 할당 그래프는 교착상태가 발생했을 때 순환 구조를 형성합니다. 순환 구조가 발견되면, 교착상태를 유발한 프로세스를 강제로 종료하고 체크포인트로 롤백하여 다시 실행합니다.
    
    자원 할당 그래프를 지속적으로 유지하고 검사해야 하기 때문에 **오버헤드**가 발생할 수 있습니다. 하지만 가벼운 교착상태 검출과 달리, 억울하게 종료되는 프로세스는 줄어듭니다.
