## CPU 스케줄링

### CPU 스케줄링 개요

- 컴퓨터의 자원은 크게 두가지로 구분 할 수 있다.
- 1. 필수장치 : CPU, 메모리
- 2. 주변장치 : 하드디스크, 키보드, 마우스

- 프로그램을 실행시키면 메모리에 프로세스가 생성되고 각 프로세스에는 1개 이상의 쓰레드가 있습니다.
- 프로세스들은 CPU를 차지하기 위해서 운영체제의 명령을 기다리고 있습니다.
- 운영체제는 모든 프로세스에게 CPU를 할당/해제 하는데 이를 'CPU 스케줄링' 이라고 한다.

- CPU 스케줄링에서 스케줄러(운영체제)가 고려해야 할 사항 두가지
- 1. 어떤 프로세스에게 CPU 리소스를 줘야하는가?
- 메모리에는 수 많은 프로세스들이 있는데 여기서 "어떤 프로세스에게 CPU 사용권을 줘야하는가" 한 프로세스에게만 계속 할당한다면 다른 프로세스 들이 불만이 많겠죠?
- 2. CPU를 할당받은 프로세스가 얼마의 시간동안 CPU를 사용해야 하는가?
- 오늘날은 시분할 처리방식으로 여러 프로세스에게 짧은 시간동안 돌아가면서 CPU를 할당합니다.
- 예를 들어 프로세스 A에게 1초동안 CPU 이용권을 주고 1초가 지나면 CPU를 뺏어서 프로세스 B에게 1초동안 CPU 이용권을 주는 방식입니다.
- 지금 말한 이 두가지 고려사항이 컴퓨터의 성능에 굉장히 큰 영향을 미칩니다.
- CPU를 할당받아 실행하는 작업을 CPU Burst라고 부르고 입출력 작업을 I/O Burst라고 부릅니다.

### 다중큐

- CPU 스케줄러는 "준비상태의 다중큐" 에 들어있는 프로세스들 중에 적당한 프로세스를 선택해서 실행상태로 전환시킵니다.
- 프로세스 정보를 담고있는 PCB는 준비상태의 다중큐에 들어가서 실행되기를 기다리고있고 CPU스케줄러에 의해 실행상태로 전환됩니다.
- 이때 CPU스케줄러는 준비상태의 다중큐를 참조해서 어떤 프로세스를 실행시킬지 결정합니다.

- I/O 작업도 비슷한데 실행중인 프로세스에서 I/O 작업이 발생하면 해당 I/O 작업의 종류별로 나뉜 큐에 들어가고 CPU 스케줄러는 이를 참조해 스케줄링 합니다.

### 스케줄링의 목표

- 1. 리소스 사용률
- 2. 오버헤드 최소화
- 3. 공평성
- 4. 처리량
- 5. 대기시간
- 6. 응답시간

### FIFO (First In First Out)

- 들어온 순서대로 CPU를 할당받아 작업을 처리합니다.
- 장점: 단순하고 직관적임.
- 단점: 한 프로세스가 끝나야 다음 프로세스가 처리되므로 비효율적일 수 있습니다.

### SJF (Shortest Job First)

- CPU Burst가 짧은 프로세스부터 먼저 실행하는 방식.
- 문제점: 각 프로세스의 Burst Time을 정확히 예측하기 어렵고, 긴 Burst Time을 가진 프로세스가 계속 지연되는 불공평한 상황이 발생할 수 있음.

### RR (Round Robin)

- 각 프로세스에게 일정 시간(타임 슬라이스)을 할당하여 처리하는 방식.
- 단점: 컨텍스트 스위칭이 자주 발생하면 오버헤드가 증가할 수 있음.
- 타임 슬라이스가 너무 크면 응답 속도가 느려지고, 너무 작으면 오버헤드가 커집니다.

### MLFQ (Multi Level Feedback Queue)

- 우선순위가 다른 여러 큐를 사용하여 CPU 사용률과 응답 속도를 동시에 고려한 스케줄링.
- CPU 사용이 많은 프로세스는 낮은 우선순위로 이동하며, 최종적으로 FIFO 방식처럼 동작합니다.

## 프로세스 동기화

### 프로세스 간 통신

- 프로세스는 독립적으로 실행되기도 하지만 다른 프로세스와 데이터를 주고받으며 통신을 하는 경우도 있습니다.
- 프로세스간 통신방법
- 1. 한 컴퓨터 내에서 프로세스 간 통신을 하는 방법
- 파일과 파이프를 이용하는 방법

- 2. 쓰레드를 이용하는 방법
- 한 프로세스 내에서 쓰레드간 통신을 하는 방법 (프로세스간 통신 X)

- 3. 네트워크를 이용한 방법
- 운영체제가 제공하는 소켓통신이나 다른 컴퓨터에 있는 함수를 호출하는 RPC(원격 프로시저 호출)을 이용해 통신하는 방법

### 공유자원과 임계구역

- 공유자원 : 프로세스 간 통신을 할 때 공동으로 이용하는 변수나 파일들
- 컨텍스트 스위칭으로 시분할 처리를 하기 때문에 어떤 프로세스가 먼저 실행되고 어떤 프로세스가 나중에 나중에 실행되는지 예측하기가 힘들다는 것
- 따라서 연산 결과를 예측하기 힘들고 여기서 발생한 문제를 "동기화 문제" 라고 합니다.
- 임계구역 : 여러 프로세스가 동시에 사용하면 안되는 영역
- 경쟁조건 : 공유자원을 서로 사용하기 위해 경쟁하는 것

- 임계구역에서 발생하는 문제를 해결하기 위한 기법 - 상호 배제
- 상호 배제의 메커니즘 3가지
- 1. 임계영역엔 동시에 하나의 프로세스만 접근한다.
- 2. 여러 요청에도 하나의 프로세스의 접근만 허용한다.
- 3. 임계구역에 들어간 프로세스는 빠르게 나와야한다.

### 세마포어 - 상호 배제의 메커니즘 중 1가지

- 방: 공유자원
- 공유자원을 쓰기위해 기다리는 것: 대기큐
- 방에 들어가기 위한 열쇠: 세마포어

### 모니터

- 모니터 : 세마포어의 단점을 해결한 상호 배제 메커니즘
- synchronized 라는 키워드가 붙으면 동시에 여러 프로세스에서 실행 시킬수 없다.

### 데드락 (교착상태)

- 교착상태 : 여러 프로세스가 서로 다른 프로세스의 작업이 끝나기를 기다리다가 아무도 작업을 진행하지 못하는 상태
- 교착상태가 발생하는 이유는 공유자원 때문입니다.
- 교착상태의 필요조건 (이 중 한 가지라도 충족하지 않는다면 교착상태가 되지않는다)
- 1. 상호 배제
- 2. 비선점
- 3. 점유와 대기
- 4. 원형 대기
- 이걸 이용해서 교착상태를 예방하려고 했으나 제약이 많고 굉장히 비효율적이라 다른 방식을 연구해야 했습니다.

### 데드락 해결 (교착상태 해결)

- 교착상태 회피
- 프로세스들에게 자원을 할당할 때 어느정도 자원을 할당해야 교착상태가 발생하는지 파악해서 교착상태가 발생하지 않는 수준의 자원 할당을 합니다.
- 전체 자원, 할당된 자원을 기준으로 안정상태와 불안정상태로 나뉩니다.
- 운영체제는 최대한 안정상태를 유지하려고 자원할당을 합니다.

- 교착상태가 발생하면 이를 검출하고 해결하는 방법도 연구되었습니다.
- 1. 가벼운 교착상태 검출
  - 타이머: 프로세스가 일정 시간 동안 작업을 진행하지 않으면 교착상태가 발생한 것으로 간주하고 해결합니다.
  - 체크포인트 롤백: 작업 진행 중 주기적으로 상태를 저장하고, 교착상태가 발생하면 저장했던 지점으로 롤백합니다. 이는 게임에서 롤백하는 매커니즘과 유사합니다.
- 2. 무거운 교착상태 검출
  - 자원 할당 그래프: 현재 운영체제에서 어떤 프로세스가 어떤 자원을 사용하는지 감시하고, 교착상태가 발생하면 이를 해결합니다.
  - 자원 할당 그래프는 교착상태가 발생했을 때 순환 구조를 형성합니다. 순환 구조가 발견되면, 교착상태를 유발한 프로세스를 강제로 종료하고 체크포인트로 롤백하여 다시 실행합니다.
- 자원 할당 그래프를 지속적으로 유지하고 검사해야 하기 때문에 **오버헤드**가 발생할 수 있습니다. 하지만 가벼운 교착상태 검출과 달리, 억울하게 종료되는 프로세스는 줄어듭니다.
