[ Section 3 ] CPU 스케쥴링
	1. CPU 스케쥴링 개요
		1) CPU 스케쥴링 : 운영체제가 모든 프로세스에게 CPU를 할당/해제 하는 것.
		2) CPU 스케쥴링 고려사항 ( 2가지 )
			2-1) 어떤 프로세서에게 CPU 리소스를 주어야 하는가?
			2-2) CPU를 할당받은 프로세스가 얼마으 ㅣ시간동안 CPU를 사용해야 하는가?
		3) CPU Burst( 벌스트 ) : CPU를 할당받아 실행하는 작업
		4) I/O Burst( 벌스트 ) : I/O를 할당받아 입출력 작업
		
	2. 다중큐
		1) 프로세스 상태에서 프로세스가 대기하고 있는 준비상태와 대기상태는 큐(Queue)라는 자료구조로 관리됨.
		2) 큐( Queue ) : 먼저 들어온 것을 가장 먼저 처리를 하고 나중에 온 것은 나중에 처리받는 구조
		3) 스택( Stack ) : 먼저 들어온 게 나중에 처리받고 나중에 들어온게 먼저 처리받는 구조
		4) 프로세스는 우선순위에 따라 맞는 준비 큐에 넣어짐.
		5) CPU 스케쥴러는 준비상태의 다중큐에 있는 프로세스들 중 선택하여 실행상태로 전환함.
		6) 이 때 프로세스는 프로세스의 정보를 가지고 있는 프로세스 제어 블록( PCB )이 준비 큐에 들어가게 됨.
		7) I/O 작업도 유사함.
		   
	3. 스케쥴링 목표
		1) 리소스 사용율
		2) 오버헤드 최소화
		3) 공평성 : 모든 프로세스에게 공평하게 CPU 할당되어야 함.
				  단, 시스템에 따라 공평에 의미가 달라짐.
		4) 처리량 
		5) 대기 시간
		6) 응답 시간
	
	4. FIFO( First In First Out )
		1) 스케쥴링 큐에 들어온 순서대로 CPU를 할당받는 방식
		2) 장점 : 단순하고 직관적임.
		3) 단점 
			3-1) CPU 사용율 저하.
			3-2) 실행시간 무관하게 먼저 들어온 프로세스가 끝나야 다름 프로세스가 진행됨.
			3-3) 작업 순서에 따라 평균 대기시간이 달라짐.
	
	5. SJF( Shortest Jop First )
		1) Burst 타임이 짧은 프로세스를 먼저 실행하는 알고리즘.
		2) 장점 : 이론적으로 FIFO보다 성능이 좋음.
		3) 단점 
			3-1) 어떤 프로세스가 얼마나 실행될지 예측이 어려움.
			3-2) 버스트 타임이 긴 프로세스는 아주 오랫동안 실행되지 않을 수 있음.
		
	
	6. RR( Round Robin )
		1) Round Robin 알고리즘.
			- 일정 시간만큼만 프로세스에 CPU를 할당함.
			- 일정 시간이 초과한 경우 강제로 다른 프로세스에 일정 시간만큼 CPU를 할당함.
			- CPU를 뺏긴 프로세스는 큐( Queue )의 가장 뒷부분으로 밀려남.
		2) 타임 슬라이스( = 타임 퀀텀 ) : 프로세스에게 할당하는 일정 시간.
		3) FIFO와 RR 알고리즘의 평균 대기 시간이 비슷한 경우 RR 알고리즘이 더 비효율적임.
			→ 컨텍스트 스위칭이 존재하므로.
		4) RR 알고리즘의 성능은 타임 슬라이스 값에 따라 달라짐
			4-1) 타임 슬라이스가 큰 경우
				- FIFO 알고리즘이 됨.
				- 단, 음악이나 웹브라우저 실행 시 끊키는 현상이 발생됨.
			4-2) 타임 슬라이스가 작은 경우
				- 음악이나 웹브라우저 동시 실행하는 느낌을 가질 수 있음.
				- 단, 너무 작은 경우 프로세스 처리량보다 컨텍스트 스위칭 처리량이 커짐.( 오버헤드가 너무 커짐. )
				- 따라서 적당한 타임 슬라이스 선정이 필요함.( Unix : 100ms, Windows : 20ms )
	
	7. MLFQ( Multi Level Feedback Queue )
		1) RR 알고리즘 업그레이드된 알고리즘.
		2) CPU 바운드 프로세스( CPU Bound Process )
			- 대부분의 시간을 CPU 연산 작업을 함.
			- CPU 사용율과 처리량을 가장 중요시함.
		3) I/O 바운드 프로세스( I/O Bound Process )
			- 대부분의 시간을 I/O 작업을 하고 PCU 연산은 조금만 진행함.
			- 응답 속도를 가장 중요시함.
		4) MLFQ( 멀티 레벨 피드백 큐 )
			4-1) CPU 사용율과 I/O 사용율이 좋게 나오는 작은 크기의 타임 슬라이스를 선택함.
				 즉, CPU 바운스 프로세스는 큰 타임 슬라이스를, I/O 바운스 프로세스는 작은 타임 슬라이스를  할당함.
			4-2) CPU & I/O 바운스 프로세스 구분 방법
				- CPU 할당을 스스로 반납하면, CPU 사용이 적은 것이므로 I/O 바운드 프로세스일 확률이 높음.
				- 반대로 CPU 스케쥴레에 의해 강제로 CPU를 뺏기면, CPU 사용이 많으므로 CPU 바운드 프로세스일 확률이 높음.
			4-3) 우선 순위를 가진 큐를 여러개 준비함.
				- 우선 순위가 높을 수록 타임 슬라이스가 작고 우선순위가 낮을 수록 타임 슬라이스 크기가 커짐.
			4-4) 프로세스가 강제로 CPU 할당을 뺏길때마다 더 낮은 우순순위의 큐로 이동함.
				- 최종적으로는 타임 슬라이스가 커지게 되어 FIFO처럼 연속적으로 작업을 진행하게됨.
			4-5) 가장 많이 사용하는 CPU 스케쥴링 알고리즘임.
		

[ Section 4 ] 프로세스 동기화
	1. 프로세스 간 통신
		1) 프로세스 간 통신 종류
			1-1) 파일과 파이프를 이용하는 방법
				- 파일 : 프로세스들이 하나의 파일을 이용해 읽고 쓰는 방법
				- 파이프 : 운영체제에서 생성한 파이프를 이용해 데이터 읽고 쓰는 방법
			1-2) 스레드를 이용하는 방법
				- 한 프로세스 내의 데이터 영역에 있는 전역변수나 힙을 통한 통신
			1-3) 네트워크
				- 운영체제가 제공하는 소켓 통신 및 다른 컴퓨터에 있는 함수를 호출하는 RPC( 원격 프로시저 호출 ) 방법

	2. 공유자원과 임계구역
		1) 공유자원 : 프로세스간 통신을 할 때 공동으로 이용하는 변수나 파일들을 의미함.
			- 공유 자원은 각 프로세스의 접근 순서에 따라 결과가 달라질 수 있음.
			- 컨텍스트 스위칭으로 시분할 처리를 하므로 프로세스들의 접근 순서를 알 수 없음.
		2) 임계 영역( Critical Section )
			- 여러 프로세스가 동시에 사용하면 안되는 영역
			- 임계 구역 문제를 해결하기 위해서는 상호배제의 매커니즘이 필요함.
		3) 경쟁 조건( Race Condition )
			- 공유 자원을 서로 사용하기 위해 경쟁하는 것
		4) 상호배제의 요구사항
			4-1) 임계영역엔 동시에 하나의 프로세스만 접근한다.
			4-2) 여러 요청에도 하나의 프로세스의 접근만 허용한다.
			4-3) 임계구역에 들어간 프로세스는 빠르게 나와야 한다.
			
	3. 세마포어
		1) 상호배제 매커니즘의 한가지인 세마포어로 임계영역에 접근가능한 권한을 의미함.
		2) 예를 들어 프린터실을 사용하기 위해서는 열쇠관리자의 열쇠를 가지고 있는 직원만 사용할 수 있음.
		   이 때 한명의 직원만 프린터실에서 작업을 할 수 있으며, 그 외 직원들은 밖에서 대기해야 함.
		   여기서 열쇠관리자의 열쇠가 세마포어임.
		3) 프린터를 사용하려는 직원 - 프로세스
		   프린터 - 공유자원
		   프린터를 쓰기 위해 프로세스가 대기하는 공간 - 대기 큐
		   열쇠관리자 - 운영체제
		   열쇠 - 세마포어
		4) 단점 - 웨으트 함수와 시그널 함수의 순서 실수할 가능성 있음.
		
	4. 모니터
		1) 세마포어의 단점을 해결한 상호배제 매커니즘임.
		2) 프로그래밍 언어차원에서 지원하는 방법임.
		3) ex) Java - Synchronized 키워드	
			상기 키워드가 붙은 함수는 동시에 여러 프로세스에서 실행할 수 없음.
	
[ Section 5 ] 데드락( 교착 상태 )
	1. 데드락이란?( feat. 식사하는 철학자 )
		1) 데드락 : 여러 프로세스가 서로 다른 프로세스의 작업이 끝나기를 기다리다가 아무런 작업을 진행하지 못하는 상태
		2) 교착 상태가 발생하는 이유는 공유자원임.
		3) 교착 상태의 필요조건 4가지로 한가지라도 만족하지 못하면 교착상태가 발생할 수 없음.
		4) 교착 상태의 필요조건
			4-1) 상호배재 : 어떤 프로세스가 한 리소스를 점유했다면 그 리소스는 다른 프로세스에게 공유가 되면 안됨.
			4-2) 비선점 : 프로세스 A가 리소스를 점유하고 있는데 다른 프로세스가 리소스를 빼앗을 수 없음.
			4-3) 점유와 대기 : 어떤 프로세스가 리소스 A를 가지고 있는 상태에서 추가적으로 리소스 B를 원하는 상태
			4-4) 원형 대기 : 점유와 대기를 하는 프로세스들의 관계가 원형을 이루는 상태
	
	2. 데드락 해결( feat. 은행원 알고리즘 )
		1) 교착상태 회피
			- 자원 할당 시 어느 정도 자원을 할당해야 교착상태가 발생하는지 파악해 교착상태가 발생하지 않는 수준의 자원을 할당함.
		2) 교착상태 회피는 전체 자원의 수와 할당되 자원의 수 기준으로 안전상태와 불안전상태로 나눔.
		3) 총 자원 : 프로세스에게 자원 할당 전의 운영체제의 전체 자원의 수
		4) 최대 요구 자원 : 프로세스들은 각자 자기가 필요한 자원의 최대 숫자
		5) 안정 상태
			- 현재 운영체제가 할당 가능한 자원이 현재 프로세스들에게 할당된 자원 외 요청이 예상되는 자원을 지원할 수 있는 경우
			- 추가 지원을 통해 프로세스를 빠르게 종료시켜 자원을 추가 확보하여 다른 프로세스들에게 추가 지원을 함.
		6) 불안정 상태 
			- 현재 운영체제가 할당 가능한 자원이 현재 프로세스들에게 할당된 자원 외 요청이 예상되는 자원을 지원할 수 없는 경우
			- 만약 추가 요청을 프로세스가 하지 않으면, 교착상태에 빠지지 않음.
		7) 교착상태 검출 방법
			1) 가벼운 교착상태 검출
				- 타이머를 이용하여 프로세스가 일정시간동안 작업을 진행하지 않는 경우 교착상태가 발생하여 간주함.
				- 일정 시점마다 체크 포인트를 만들어 작업을 저장하고 타임아웃으로 교착상태 발생시 마지막으로 저장됨
				  체크 포인트로 롤백하는 것임.
			2) 무거운 교착상태 검출
				- 자원 할당 그래프를 이용하며, 이를 위해 운영체제가 자원 사용을 모니터링 함.
				- 자원 할당 그래프에서 프로세스 간의 순환구조가 발생하는 경우 교착상태가 생긴 그래프이며,
				  순환구조가 없는 경우 교착상태가 없음으로 판단함.
				- 교착 상태 검출 시 프로세스 강제 종료하고 다시 실행시 마지막 체크포인트로 롤백함.
				- 단점은 자원할당 그래프 유지 및 검사를 위해 오버헤드 발생함.
				- 장점은 가벼운 교착상태 검출 방법보다는 정확하게 교착상태 검출이 가능함.
			
